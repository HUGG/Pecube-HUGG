c Implementers notes:
c
c 
c This fortran file is compiled with a number of different
c compiler flags in order to allow it to do different things.
c
c      
c no flags: Basic NA proceedure for use with malcolms
c           na. User supplies subroutines forward/user_init/writemodels
c           and then links with this file.
c
c
c -DNA_MPI=1 flag: MPI version of NA code. Same as above
c           but the produced executable can then be run with 
c           the mpirun command
c
c -DNA_MPIP flag: NA is compiled to work with MPI, but also 
c           includes some modifications to make it run faster
c           (the concept of a discrete 'iteration' is removed, 
c           and na runs in 'continuous' mode). 
c
c 
c*************************************************************************
c
c	Main subroutine NA  - sampling a parameter space
c		      	      using a Neighbourhood algorithm
c
c	Input files:
c		    na.in	- Options for Neighbourhood algorithm
c
c	Output files:
c		    na.sum	- summary of results
c		    na.nad	- NAD (NA direct access file of models)
c		    sobol.coeff	- initializing data used for 
c				  quasi-random sequences
c
c	Comments:
c		 The NAD file is a direct access compact format file
c		 containing all models generated by the neighbourhood
c		 algorithm. (NAD files can be read in by multi-dimensional 
c		 integration program NA-Bayes and plot program S-plot.)
c
c					M. Sambridge, (RSES, ANU)
c					Last revision July 2004. 
c
c*************************************************************************
c
#if defined NA_MPIP
        ! continuous MPI standalone version
        Subroutine NA (ndin,rangein)
        !write(*,*)'In NA subroutine .... calling NAMPIP()'
        CALL NAMPIP(ndin, rangein)
        end
        Subroutine NA_notused
#else
        ! normal NA program, that user does
        ! compiling/linking of. Can be either
        ! MPI enabled (if -DNA_MPI=1) or not.
        Subroutine NA(ndin, rangein)
#endif    

! The following routine is the NA routine in
! the discrete versions of NA. If NA_MPIP is
! defined, the following function is ignored,
! and NAMPIP() does the work instead.       

        
c
c						MPI definitions
#if NA_MPI
        include "mpif.h"
#endif

c
c						Set up all dimensions for 
c						arrays used by NA routines
        
        integer         numberOfModels

c						F77 fixed array sizes
#if NA_F77_COMPATIBILITY
        include 'na_param.inc'
        real*4  misfit(nmod_max)
        real*4  sum(nsample_max)
        real*4  na_models(nd_max*nmod_max)
        real*4  range(2,nd_max)
        real*4  ranget(2,nd_max)
        real*4  scales(nd_max+1)
        real*4  na_model(nd_max)
        real*4  xcur(nd_max)
        integer mfitord(nsample_max)

        real*4  work_NA1(nmod_max)
        real*4  work_NA2(nmod_max)

        integer iwork_NA1(nmod_max) 
        integer iwork_NA2(nsample_max)

        real*4  rangein(2,nd_max)
        integer ndin

#else
c						F90 Dynamic allocatable arrays 

        parameter       (nh_max=1000, nsleep_max=1, maxseq=50)
        parameter (nd_max = 1024)     !no more than 1024 parameters
        real*4, allocatable :: misfit(:)  !misfit(nmod_max)
        real*4, allocatable :: sum(:)     !sum(nsample_max)
        real*4, allocatable :: na_models(:) !na_models(nd_max*nmod_max),
        real*4 range(2,nd_max)   !range(2,nd_max),
        real*4 ranget(2,nd_max)  !ranget(2,nd_max),
        real*4 scales(nd_max+1)  !scales(nd_max+1),
        real*4, allocatable :: na_model(:) !na_model(nd_max),
        real*4, allocatable :: xcur(:)     !xcur(nd_max)
        integer, allocatable :: mfitord(:) !mfitord(nsample_max)
        
        real*4, allocatable :: work_NA1(:) !nmod_max
        real*4, allocatable :: work_NA2(:) !nmod_max
       
        integer, allocatable :: iwork_NA1(:) !nmod_max
        integer, allocatable :: iwork_NA2(:) !nsample_max

        real*4  :: rangein(2,nd_max)
        integer :: ndin
#endif
        
        character       header(nh_max)
        character*256   fnme
        real*8          timedouble1, timedouble2, tstartTime, tendTime
        real*4          minfwd, maxfwd
        
        real*4          misfitval,mfitmin,mfitmean,mfitminc
      

c
        logical         monte,
     &                  verbose,
     &                  summary,
     &                  timing,
     &                  debug,
     &                  check,
     &                  restartNA,
     &                  noforward,
     &                  calcmovement

        logical         lroot
c
c						Some bookeeping variables
c						not used by NA routines
#if NA_F77_COMPATIBILITY
        real  model_opt(nd_max)
#else
        real, dimension(:), allocatable :: model_opt   !(nd_max)
#endif
        integer         nproc, iproc, ierr
        real          tmpiall
c
c						Info and Logical unit common 
c						blocks used by NA routines
c
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary


        common /NA_info/nxsave,ndsave,ndc,nerr,ncald,nupd,
     &                  cells,torder,taxis,tup,tcd,tdev,tna,tres

        common /NA_info_special/taxis2

        common /NAMPI/iproc,nproc,lroot

c
c		Set up logical units 
c						LU's for standard output
        lu_out = 6
c
c
c	       	Set up logical units for Neighbourhood Algorithm files
c 
c						LU for input of NA options
c
        lu_na = 30
c						LU for input of quasi random
c						number generator data
c						(sobol sequence data)
        lu_sob = 31
c						LU for output of information
c						summarising NA performance. 
        lu_sum = 32
c						LU for output of more detailed
c						information to file na.det
        lu_det = 33
c						LU for output of sample 
c						density in best voronoi cell
c						(Only used if calcmovement
c						 is set to true and NA_PDF
c						 is not used)
c						
c						LU for NAD input/output file
        lu_nad = 34
c						LU for special info file
        lu_dis = 35

c						set up variables
c						and start MPI
        iproc = 0
        nproc = 1
        lroot = .false.

#if NA_MPI
        call MPI_Init(ierr )      
        call MPI_Comm_size( MPI_COMM_WORLD, nproc, ierr ) 
        call MPI_Comm_rank( MPI_COMM_WORLD, iproc, ierr ) 
c	write(*,*)' MPI called nproc = ',nproc
        if(verbose)call na_printhostname(iproc)
#endif
        if(iproc.eq.0)lroot = .true.

c	write(*,*)' I am node ',iproc,' lroot = ',lroot

c						User specific setup for 
c						forward modelling
c
        nd=ndin
        range(:,1:nd)=rangein(:,1:nd)
        call user_init(nd,range,scales)

        
        if(nd.le.0)then
            write(*,*)
            write(*,*)' Error in user supplied routine user_init'
            write(*,*)
            write(*,*)' Number of dimensions in parameter space '
            write(*,*)' is less than or equal to zero'
            write(*,*)' This must be an error in the users code'
            write(*,*)
            write(*,*)' Remedy: fix the code '
            write(*,*)
            stop
        end if
        if(nd.gt.nd_max)then
            write(*,*)
            write(*,*)' Sorry, NA cant currently handle that'
            write(*,*)' many dimensions.'
            
            write(*,*)' Number of dimensions in parameter space '
            write(*,*)' has an upper limit of ',nd_max
            write(*,*)
            stop
        end if
        

c						
c						Open NA input files
c
        open(lu_na,file='NA/na.in',status='old')
c
c                                               Open NA output files
c
        if(lroot)open(lu_sum, file='NA/na.sum', status='unknown')

c						write header to standard out
        if(lroot)write(*,100)
c

c
c						Read in options for
c						Neighbourhood algorithm.
c
        call NA_options
     &       (nsleep_max, nd, nsamplei, nsample, istype, 
     &        noforward, nsleep, ncells, itmax, monte, nclean)

c						
c						Close NA input files
c
        close(lu_na)

c       Now that we have got some information about the parameter
c       space we are searching from the call to user_init and
c       reading in the na.in file, we can allocate the proper 
c       amount of space needed.
#if NA_F77_COMPATIBILITY 
        numberOfModels = nmod_max
#else
        numberOfModels = nsamplei+itmax*nsample
        allocate(misfit(numberOfModels))  !misfit(nmod_max)
        allocate(sum(max(nsample, nsamplei)))  !sum(nsample_max)
        allocate(na_models(nd*numberOfModels)) !nd_max*nmod_max
        allocate(na_model(nd))    !na_model(nd_max),
        allocate(xcur(nd))        !xcur(nd_max)

        allocate(mfitord(numberOfModels)) !mfitord(nsample_max)
        
        allocate(work_NA1(numberOfModels)) !nmod_max
        allocate(work_NA2(numberOfModels)) !nmod_max
        
        allocate(iwork_NA1(numberOfModels)) !nmod_max
        allocate(iwork_NA2(numberOfModels)) !nsample_max
        
        allocate(model_opt(nd))    !nd_max
#endif

c					set other info or debug options
        check = .true.
        check = .false.
        calcmovement = .true.
        calcmovement = .false.
        if(calcmovement)then
          if(lroot)open(lu_dis, file='distances', status='unknown')
        end if
c
c						Initialize NA routines.
c
        call NA_initialize
     &       (range,ranget,scales,numberOfModels,misfit,na_models,
     &        nd,xcur,nsample,ncells,restartNA)

c             		                	Generate or read in
c						starting models 
c
        call NA_initial_sample
     &       (na_models,nd,ranget,range,nsamplei, numberOfModels,
     &        istype,monte,calcmovement,scales,misfit)
c
c			MAIN OPTIMIZATION LOOP
c

        minfwd = -1
        maxfwd = -1
 
        ntot = 0
        nxsavet = 0
        ndsavet = 0
        ndct = 0
        nerrt = 0
        ncald = 0
        nupd = 0
        taxist = 0.
        taxist2 = 0.
        tordert = 0.
        tupt = 0.
        tcdt = 0.
        trest = 0.
        tdevt = 0.
        ttfor = 0.
        ttfwdelapsed = 0.
        tmis = 0.
        tnat = 0.
        tmpiall = 0.
        ns = nsamplei

        ! remember what time we started
        call na_walltime(tstartTime)

        t1 = cputime(t2,t3)
        
        do 20 it = 1,itmax+1
c
c						Calculate misfit values
c						for each model in the 
c						current population.
c
           if(summary.and.lroot)then
              write(*,*)
              write(*,*)' start forward modeling iteration: ',it-1
           end if

c						skip forward modelling for
c						starting models if 
c						they have been read in 
c						from a NAD file

           if(it.eq.1.and.noforward)go to 31

           call na_walltime(timedouble1)
           t1 = cputime(t2,t3)
           tnat = tnat + t2 
           do 30 i = iproc+1,ns,nproc
c						Decode current model
c						and put into array model.
c
              ii = 1+(i-1+ntot)*nd

              call transform2raw
     &             (na_models(ii),nd,range,scales,na_model)

              misfitval = 0.0


              call forward(nd, na_model, misfitval)
             
              jj = ntot + i
              misfit(jj) = misfitval
c
 30        continue

           ! work out how long we spent doing forward modelling
           t1 = cputime(t2,t3)
           ttfor = ttfor + t2
           call na_walltime(timedouble2)
           telap = (timedouble2-timedouble1)
           ttfwdelapsed = ttfwdelapsed + telap
           if(minfwd.eq.-1) minfwd=t2 !special case for 1st iteration
           minfwd = min(t2, minfwd)
           maxfwd = max(t2, maxfwd)

           if(lroot.and.timing.and.debug) then 
             write(*,*)' cpu time in forward() this iteration: ',t2
           end if 
 

           
c	   write(*,*)iproc,' : ',(misfit(k),k=1+ntot,ntot+ns)
#if NA_MPI
           call na_walltime(timedouble1)
           CALL MPI_ALLREDUCE
     &          (misfit(ntot+1), sum, ns, 
     &           MPI_REAL, MPI_SUM, MPI_COMM_WORLD, ierr)
           call na_walltime(timedouble2)
           tmpiall = tmpiall + (timedouble2-timedouble1)
#endif
           


           !forward modelling finished for this iteration
 31        if(summary.and.lroot)write(*,*)' finished forward modeling'

           if(lroot.and..not.debug) 
     &     write(*,*)' min/max cpu time for fwd ',
     &                      'on root node is ',minfwd,'/',maxfwd

           if(nproc.gt.1)then
              do i=1,ns
                 misfit(ntot+i) = sum(i)
              end do
           end if

           t1 = cputime(t2,t3)
           tnat = tnat + t2
c
c						Calculate properties of
c						current misfit distribution.
c						(Mean,min,best model etc.)

           call NA_misfits
     &          (misfit,ns,it,ntot,mfitmin,
     &           mfitminc,mfitmean,mopt,
     &           ncells,work_NA2,
     &           iwork_NA1,iwork_NA2,mfitord)

c						copy optimum model from
c						current population, to
c						array model_opt.
c
           ii = 1 + (mopt-1)*nd
c
           call transform2raw
     &          (na_models(ii),nd,range,scales,na_model)

           do j=1,nd
              model_opt(j) = na_model(j)
           end do
c
           ntot = ntot + ns
           ns = nsample
c						write out summary info
           if(verbose.and.lroot)then
              call NA_display
     &             (lu_det,model_opt,it-1,nd,ntot,
     &              mfitmin,mfitminc,mfitmean,mopt)
           end if

           t1 = cputime(t2,t3)
           tmis = tmis + t2
           tnat = tnat + t2

           if(it.eq.itmax+1)go to 99
c								     F I/O
c
c						Call main NA routines
c
           if(monte)then
c						Perform Monte Carlo 
c						search for comparison
c						to NA.
              call NA_random
     &             (na_models,nd,ranget,
     &              ntot,nsample,calcmovement)

              t1 = cputime(t2,t3)
              tnat = tnat + t2

           else 
c						generate a new sample using
c						Neighbourhood algorithm
c						(resample version)
              call NA_sample
     &             (na_models, ntot, nsample, nd, nsleep, 
     &              ncells, misfit, mfitord, ranget, 
     &              check, xcur, restartNA, 
     &              calcmovement, nclean, work_NA1)
c
c						collect info statistics
              nxsavet = nxsavet + nxsave
              ndsavet = ndsavet + ndsave
              ndct = ndct + ndc
              nerrt = nerrt + nerr
              tordert = tordert + torder
              tupt = tupt + tup
              tcdt = tcdt + tcd
              trest = trest + tres
              tdevt = tdevt + tdev
              taxist = taxist + taxis

              tnat = tnat + tna


           end if

c
 20     continue
c
c			FINISHED OPTIMIZATION LOOP
c
           
 99     continue
c
c					Some statistics

        call na_walltime(tendTime)
   
        if(summary.and.lroot)then

        write(*,*)' '
        write(*,*)' '
        write(*,*)' '
        write(*,*)'Performance statistics'
        write(*,*)' '
        write(*,*)'Total number of full dlist evaluations',ncald
        write(*,*)'Total number of partial dlist updates ',nupd
        write(*,*)'Lowest misfit found                   ',mfitmin
        write(*,*)'Average misfit over all models        ',mfitmean
        write(*,*)'Index of lowest misfit model          ',mopt
        write(*,*)
        write(lu_sum,*)
        write(lu_sum,*)
        write(lu_sum,*)
        write(lu_sum,*)'Performance statistics'
        write(lu_sum,*)' '
        write(lu_sum,*)
     &  'Total number of full dlist evaluations  ',ncald
        write(lu_sum,*)
     &  'Total number of partial dlist updates   ',nupd
        write(lu_sum,*)
     &  'Lowest misfit found                     ',mfitmin
        write(lu_sum,*)
     &  'Average misfit over all models          ',mfitmean
        write(lu_sum,*)
     &  'Index of lowest misfit model            ',mopt
        write(lu_sum,*)

        write(lu_sum,*)
     &  'Total cpu time spent partially updating dlist      ',tupt
        write(lu_sum,*)
     &  'Total cpu time spent evaluating dlist              ',tcdt
        write(lu_sum,*)
     &  'Total cpu time spent finding Voronoi intersections ',taxist
        write(lu_sum,*)
     &  'Total cpu time spent calculating random deviates   ',tdevt
        write(lu_sum,*)
     &  'Total cpu time resetting random walks              ',trest
        write(lu_sum,*)
     &  'Total cpu time for ordering misfits                ',tmis
        if(nproc.gt.1)write(lu_sum,*)
     &  'Total elapsed time for MPI_ALLREDUCE               ',tmpiall
        write(lu_sum,*)
     &  'Total elapsed wall time for fwd                    ',
     &   ttfwdelapsed
        write(lu_sum,*)
     &  'Total cpu time for NA-algorithm (without forward)  ',tnat
        write(lu_sum,*)
     &  'Total cpu time for forward modeling                ',ttfor
        write(lu_sum,*)
     &  'Minimum cpu time spent forward modelling            ',minfwd
        write(lu_sum,*)
     &  'Maximum cpu time spent forward modelling            ',maxfwd
        write(lu_sum,*)
     &  'Total elapsed time for entire NA                   ',
     &                          (tendTime-tstartTime)
        write(lu_sum,*)


        write(*,*)
     &  'Total cpu time spent partially updating dlist           ',tupt
        write(*,*)
     &  'Total cpu time spent evaluating dlist              ',tcdt
        write(*,*)
     &  'Total cpu time spent finding Voronoi intersections ',taxist
        write(*,*)
     &  'Total cpu time spent calculating random deviates   ',tdevt
        write(*,*)
     &  'Total cpu time resetting random walks              ',trest
        write(*,*)
     &  'Total cpu time for ordering misfits                ',tmis
        if(nproc.gt.1)write(*,*)
     &  'Total elapsed time for MPI_ALLREDUCE               ',tmpiall
        write(*,*)
     &  'Total elapsed wall time for fwd                    ',
     &   ttfwdelapsed
        write(*,*)
     &  'Total cpu time for NA-algorithm (without forward)  ',tnat
        write(*,*)
     &  'Total cpu time for forward modeling                ',ttfor
        write(*,*)
     &  'Minimum cpu time spent forward modelling            ',minfwd
        write(*,*)
     &  'Maximum cpu time spent forward modelling            ',maxfwd
        write(*,*)
     &  'Total elapsed time for entire NA                   ',
     &                          (tendTime-tstartTime)
        write(*,*)

        end if

c						transform all models
c						back to scaled units
        do i=1,ntot
           ii = 1 + (i-1)*nd
           call transform2raw
     &          (na_models(ii),nd,range,scales,na_models(ii))
        end do

        nh = 1
c						call user supplied I/O routine
        if(lroot)call writemodels 
     &       (nd, ntot, na_models, misfit,
     &        nsamplei, nsample, itmax, nh_max, nh, header)
c
c
c                                               write out ensemble of models
c                                               as a direct access file
        
c						add NA-info to begining
c						of header file
c
        fnme = 'NA/na.nad'
        if(lroot)call NA_header
     &       (lu_nad,fnme,header,nh_max,nh,nd,
     &        range,scales,nsamplei,nsample,ncells,nh_user)

c
        if(summary.and.lroot)then
           write(*,*)' Total length of header in (nad) direct ',
     &               ' access model file = ',nh
           write(*,*)
           write(*,*)' Writing direct access file...'
           write(*,*)
        end if
c                                               write direct access nad file
 
        fnme = 'NA/na.nad'
        if(lroot)call write_nad
     &       (lu_nad,fnme,nd,ntot,
     &        nh,nh_user,header,1,na_models,misfit)

c						
c						Close NA summary file
c
        if(lroot)close(lu_sum)
        if(lroot)close(lu_det)
        close(lu_sob)
        if(calcmovement)close(lu_dis)
c						Advise of files created
        if(lroot)then

        write(*,*)
        write(*,*)' Files created:'
        write(*,*)
        write(*,*)
     &  ' na.nad : Direct access file containing ensemble of models ' 
        write(*,*)
     &  ' na.sum : Short summary file of progress' 
        if(verbose)write(*,*)
     &  ' na.det : Full details of progress' 
        write(*,*)

        end if
c
 100    format(/1x,35('-')/
     &          1x,'|',33x,'|'/
     &          1x,'|',5x,'Parameter space search',6x,'|'/,
     &          1x,'|',' using a Neighbourhood Algorithm ','|'/
     &          1x,'|',33x,'|'/
     &          1x,35('-')/)
 

#if NA_MPI
          call MPI_Finalize(ierr)
#endif

        return
        end


































        




        


! This is the 'main' routine if we are compiling the continuous
! MPI version of NA 
!
! implemented by Peter Rickwood  (May, 2004)
#ifdef NA_MPIP
        Subroutine NAMPIP(ndin,rangein)
c
c						MPI definitions
        include "mpif.h"
        !we use this to keep track of our most recent send
        integer requestmpi
        integer statusmpi(MPI_STATUS_SIZE)

        !we need to attach a buffer to store messages
        !We do this later using MPI_BUFFER_ATTACH
        real*4, allocatable :: buffermpi(:)
c
c						Set up all dimensions for 
c						arrays used by NA routines
        integer         numberOfModels

        parameter       (nh_max=1000, nsleep_max=1, maxseq=50)
        parameter (nd_max = 1024)     !no more than 1024 parameters
        real*4, allocatable :: misfit(:)  !misfit(nmod_max)
        real*4, allocatable :: sum(:)     !sum(nsample_max)
        real*4, allocatable :: na_models(:) !na_models(nd_max*nmod_max),
        real*4 range(2,nd_max)   !range(2,nd_max),
        real*4 ranget(2,nd_max)  !ranget(2,nd_max),
        real*4 scales(nd_max+1)  !scales(nd_max+1),
        real*4, allocatable :: na_model(:) !na_model(nd_max),
        real*4, allocatable :: xcur(:)     !xcur(nd_max)
        integer, allocatable :: mfitord(:) !mfitord(nsample_max)
        
        real*4, allocatable :: work_NA1(:) !nmod_max
        real*4, allocatable :: work_NA2(:) !nmod_max
       
        integer, allocatable :: iwork_NA1(:) !nmod_max
        integer, allocatable :: iwork_NA2(:) !nsample_max

        real*4  :: rangein(2,nd_max)
        integer :: npin
        
        character       header(nh_max)
        character*256   fnme
        
        real*8          timedouble1, timedouble2,tstartTime,tendTime
 
        real*4          misfitval,mfitmin,mfitmean,mfitminc


c
        logical         monte,
     &                  verbose,
     &                  summary,
     &                  timing,
     &                  debug,
     &                  check,
     &                  restartNA,
     &                  noforward,
     &                  calcmovement

        logical         sobol

        logical         lroot
        integer         completed

        integer         numMailboxEntries
        real            tmpiall

c
c						Some bookeeping variables
c						not used by NA routines
        real, dimension(:), allocatable :: model_opt   !(nd_max)
        integer         nproc, iproc, ierr


        
c
c						Info and Logical unit common 
c						blocks used by NA routines
c
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary


        common /NA_info/nxsave,ndsave,ndc,nerr,ncald,nupd,
     &                  cells,torder,taxis,tup,tcd,tdev,tna,tres

        common /NA_info_special/taxis2

        common /NAMPI/iproc,nproc,lroot
        common/randomtype/sobol,iseed
 
       
c
c		Set up logical units 
c						LU's for standard output
        lu_out = 6
c
c
c	       	Set up logical units for Neighbourhood Algorithm files
c 
c						LU for input of NA options
c
        lu_na = 30
c						LU for input of quasi random
c						number generator data
c						(sobol sequence data)
        lu_sob = 31
c						LU for output of information
c						summarising NA performance. 
        lu_sum = 32
c						LU for output of more detailed
c						information to file na.det
        lu_det = 33
c						LU for output of sample 
c						density in best voronoi cell
c						(Only used if calcmovement
c						 is set to true and NA_PDF
c						 is not used)
c						
c						LU for NAD input/output file
        lu_nad = 34
c						LU for special info file
        lu_dis = 35

c						set up variables
c						and start MPI
        iproc = 0
        nproc = 1
        lroot = .false.


c        write(*,*)'About to call MPI_Init'
        call MPI_Init(ierr )      
c        write(*,*)'Called MPI_Init, ierr is ',ierr
        call MPI_Comm_size( MPI_COMM_WORLD, nproc, ierr ) 
        call MPI_Comm_rank( MPI_COMM_WORLD, iproc, ierr ) 
c        write(*,*)'NAMPIP: MPI initialized in ',iproc
       
        call na_printhostname(iproc)
       

        if(nproc .lt. 2) then
                write(*,*)
                write(*,*)' Continuous NA in parallel only makes sense' 
                write(*,*)' if you have more than 1 node'
                write(*,*)
                stop
        end if
                
       
        if(iproc.eq.0)lroot = .true.

c        write(*,*)' I am node ',iproc,' lroot = ',lroot

c						User specific setup for 
c						forward modelling
c
        nd=ndin
        range(:,1:nd)=rangein(:,1:nd)
        call user_init(nd,range,scales)
        
        if(nd.le.0)then
            write(*,*)
            write(*,*)' Error in user supplied routine user_init'
            write(*,*)
            write(*,*)' Number of dimensions in parameter space '
            write(*,*)' is less than or equal to zero'
            write(*,*)' This must be an error in the users code'
            write(*,*)
            write(*,*)' Remedy: fix the code '
            write(*,*)
            stop
        end if
        if(nd.gt.nd_max)then
            write(*,*)
            write(*,*)' Sorry, NA cant currently handle that'
            write(*,*)' many dimensions.'
            
            write(*,*)' Number of dimensions in parameter space '
            write(*,*)' has an upper limit of ',nd_max
            write(*,*)
            stop
        end if
        
c						Open NA input files
c
        open(lu_na,file='NA/na.in',status='old')
c
c                                               Open NA output files
c
        if(lroot)open(lu_sum, file='NA/na.sum', status='unknown')

c						write header to standard out
        if(lroot)write(*,100)
c

c
c						Read in options for
c						Neighbourhood algorithm.
c
        call NA_options
     &       (nsleep_max, nd, nsamplei, nsample, istype, 
     &        noforward, nsleep, ncells, itmax, monte, nclean)
       
c						Close NA input files
c
        close(lu_na)


        if(monte) then
            write(*,*)' If you want to do uniform sampling, then'
            write(*,*)' there is no reason for you to use the' 
            write(*,*)' continuous parallel version of NA'
            write(*,*)' You wont get any speed increase'
            write(*,*)
            write(*,*)' Because of this NAMPIP does not support'
            write(*,*)' Uniform Monte Carlo Sampling. The standard'
            write(*,*)' version of NA already does that, so use'
            write(*,*)' it instead'
            write(*,*)
            stop
        end if
        if(sobol) then
            write(*,*)'Quasi-random random number generation'
            write(*,*)'is disallowed in the NAMPIP version'
            write(*,*)''
            write(*,*)'We do not plan to implement it. Please'
            write(*,*)'use default pseudo-random generation'
            write(*,*)''
            stop
        end if            


c       Now that we have got some information about the parameter
c       space we are searching from the call to user_init and
c       reading in the na.in file, we can allocate the proper 
c       amount of space needed.
        numberOfModels = nsamplei+itmax*nsample
        allocate(misfit(numberOfModels))  !misfit(nmod_max)
        allocate(sum(max(nsample, nsamplei)))  !sum(nsample_max)
        allocate(na_models(nd*numberOfModels)) !nd_max*nmod_max

        !na_model holds the model we are currently working on,
        !or have just finished working on. We stick the misfit
        !on the end (na_model(nd+1)) just for convenience when
        !we send it to the other nodes.
        allocate(na_model(nd+2))    !na_model(nd_max)... +1 for misfit
                                    !+1 leftover slot for future use,
                                    !but currently unused
        allocate(xcur(nd))        !xcur(nd_max)

        allocate(mfitord(numberOfModels)) !mfitord(nsample_max)
        
        allocate(work_NA1(numberOfModels)) !nmod_max
        allocate(work_NA2(numberOfModels)) !nmod_max
        
        allocate(iwork_NA1(numberOfModels)) !nmod_max
        allocate(iwork_NA2(numberOfModels))  !nsample_max
        
        allocate(model_opt(nd))    !nd_max

        nmpibufsize = (nd+2+MPI_BSEND_OVERHEAD/4+1)*numberOfModels
        allocate(buffermpi(nmpibufsize))

        !currently, we attach a pretty big buffer for message
        !bufferring (almost big enough to hold all the models.....
        !this is almost certainly more than we need in reasonable 
        !circumstances).
        !
        !NB: some of this buffer space gets taken up by MPI
        !so we actually have a little less than we specify here
        call MPI_BUFFER_ATTACH(buffermpi,nmpibufsize*4,ierr)

        
c					set other info or debug options
        check = .true.
        check = .false.
        calcmovement = .true.
        calcmovement = .false.
        if(calcmovement)then
          if(lroot)open(lu_dis, file='distances', status='unknown')
        end if
c
c						Initialize NA routines.
c
        ! we want the first generation to be the same for all
        ! nodes, but different after that. We keep a copy of
        ! the initial seed.
        iseedcopy = iseed
        call NA_initialize
     &       (range,ranget,scales,numberOfModels,misfit,na_models,
     &        nd,xcur,nsample,ncells,restartNA)

c             		                	Generate or read in
c						starting models 
c
        na_models = 0.0
        misfit = 0.0
        call NA_initial_sample
     &       (na_models,nd,ranget,range,nsamplei, numberOfModels,
     &        istype,monte,calcmovement,scales,misfit)


c        write(*,*)'worked out initial sample population in ',iproc

        !now we reinitialize the random number generator to be different
        !on each node
        iseed = -(iseedcopy+iproc)
        a = ran3(iseed)
        
        ntot = 0
        nxsavet = 0
        ndsavet = 0
        ndct = 0
        nerrt = 0
        ncald = 0
        nupd = 0
        taxist = 0.
        taxist2 = 0.
        tordert = 0.
        tupt = 0.
        tcdt = 0.
        trest = 0.
        tdevt = 0.
        ttfor = 0.
        ttfwdelapsed = 0.
        tmis = 0.
        tnat = 0.
        tmpiall = 0.
        ns = nsamplei

        !remember what time we started
        call na_walltime(tstartTime)
       
        t1 = cputime(t2,t3)
        
        ! Even in the continuous case, we sync on the first
        ! iteration. That is, we do the inital sample, and then
        ! do an MPI_ALLREDUCE, before each node starts doing its
        ! own thing at its own speed
        ii = iproc

        if (.not.noforward) then
            do while (ii .lt. nsamplei)
                call transform2raw
     &              (na_models(ii*nd+1),nd,range,scales,na_model)
                misfitval = 0.0

c                write(*,*)'calling forward for ',ii,' in proc ',iproc
                call na_walltime(timedouble1)
                t1 = cputime(t2,t3)
                tnat = tnat + t2
                call forward(nd, na_model, misfitval)
                t1 = cputime(t2,t3)
                ttfor = ttfor + t2
                call na_walltime(timedouble2)
                telap = timedouble2-timedouble1
                ttfwdelapsed = ttfwdelapsed + telap

                misfit(ii+1) = misfitval
                if(debug) write(*,*)'initial sample misfit is ',misfitval

                ii = ii + nproc
            enddo

            ! everyone waits for the results of the initial iteration
            call na_walltime(timedouble1)
            CALL MPI_ALLREDUCE 
     &          (misfit, sum, ns, 
     &           MPI_REAL, MPI_SUM, MPI_COMM_WORLD, ierr)
            if(ierr .ne. MPI_SUCCESS) then
                write(*,*)'MPI ALLREDUCE call failed for node',iproc
                write(*,*)'Aborting'
                call abort
            end if

            call na_walltime(timedouble2)
            tmpiall = tmpiall + (timedouble2 - timedouble1)
        else
            do i=1,ns
                sum(i)=misfit(i)
            enddo
        endif

        do i=1,ns
            misfit(i) = sum(i)
        end do

        if(lroot .and. debug) then
            write(*,*)'about to enter first NA_misfits'
        end if

        t1 = cputime(t2,t3)
        tnat = tnat + t2
        it=1 !needed for initialization of mfitmin
        call NA_misfits
     &      (misfit,ns,it,ntot,mfitmin,
     &       mfitminc,mfitmean,mopt,
     &       nsamplei,work_NA2,
     &       iwork_NA1,iwork_NA2,mfitord)
        it=2
        t1 = cputime(t2,t3)
        tmis = tmis + t2
        tnat = tnat + t2


        ntot = nsamplei
        if(lroot.and.verbose) then
            write(*,*)'finished initial iteration... in continuous mode'
            write(*,*)'models seen so far: ',ntot
            write(*,*)'best misfit so far is ',mfitmin
        end if

        
c			MAIN OPTIMIZATION LOOP
        do while (ntot .lt. numberOfModels)

                ns = nsample 
                !get a new model
                ii = nd*ntot+1
                !generate the next model (just one) to
                !evaluate on this node
                if(debug) then 
                    write(*,*)'getting model'
                endif
                nr = ncells
                if(debug) then
                    write(*,*)'nr: ',nr
                    write(*,*)'ntot: ',ntot
                endif

                !root node should not be busy right at the end
                if(lroot .and. (ntot+nproc) .gt. numberOfModels) goto 42

                call NA_sample(na_models, ntot, -ns,  nd, nsleep, 
     &              nr, misfit, mfitord, ranget, check, xcur, 
     &              restartNA, calcmovement, nclean, work_NA1)
                tnat = tnat + tna
                
                !now do forward on that model
                call transform2raw
     &          (na_models(ii),nd,range,scales,na_model)
                misfitval = 0.0
               
                call na_walltime(timedouble1)
                t1 = cputime(t2,t3)
                tnat = tnat + t2
                if(debug) write(*,*)'calculating fwd for new model'
                call forward(nd, na_model, misfitval)
                if(debug) write(*,*)'calculated fwd -- ',misfitval
                t1 = cputime(t2,t3)
                ttfor = ttfor + t2
                call na_walltime(timedouble2)
                telap = timedouble2 - timedouble1
                ttfwdelapsed = ttfwdelapsed + telap
                
                na_model(nd+1) = misfitval

                !transform the model back into scaled units
                !before we send it
c                write(*,*)'In ',iproc,' Model (pre-trans) is ',na_model
                call transform2sca(na_model, nd, range, scales,na_model)
c                write(*,*)'In ',iproc,' Model (post-trans) is ',na_model
                

                !tell all the other nodes about it
                call na_walltime(timedouble1)
                do ii=1,nproc
                        if(debug) write(*,*)'sending to ',ii
                        call MPI_BSEND(na_model, nd+2, MPI_REAL, ii-1, 
     &                      ntot+ii, MPI_COMM_WORLD, ierr)
                        if(ierr .ne. MPI_SUCCESS) then
                            write(*,*)'MPI call failed for node',iproc
                            write(*,*)'Aborting'
                            call abort
                        end if
                end do
c                write(*,*)'In ',iproc,' finished sending'

                !listen to see if any other nodes have
                !finished. This will process all completions
                !of forward, including the one we have just done
c                write(*,*)'In ',iproc,' about to MPI_IPROBE'
42              numMailboxEntries = 0 
                call MPI_IPROBE(MPI_ANY_SOURCE, MPI_ANY_TAG, 
     &                   MPI_COMM_WORLD, completed, statusmpi, ierr)
                if(debug) write(*,*)'In ',iproc,' checking letterbox'
                if(debug) write(*,*)'something to get? ',completed
                do while (completed.ne.0)
                        !get the model
                        if(debug) write(*,*)'getting letter'
                        call MPI_RECV(na_model, nd+2, MPI_REAL, 
     &                           MPI_ANY_SOURCE, MPI_ANY_TAG, 
     &                           MPI_COMM_WORLD, statusmpi, ierr)
                        if(debug) write(*,*)'got letter'
                        if(ierr .ne. MPI_SUCCESS) then
                            write(*,*)'MPI call failed for node',iproc
                            write(*,*)'Aborting'
                            call abort
                        end if
                
                        !stick it in our na_models array
                        misfit(ntot+1) = na_model(nd+1)

                        bestmf = mfitmin
                        
                        do iii=1,nd
                                na_models(nd*ntot+iii) = na_model(iii)
                        end do
                        ntot = ntot+1
                        numMailboxEntries = numMailboxEntries+1
                        if (ntot .eq. numberOfModels) then
                                completed=0
                        else
                            !now see if there are any more to recieve
                            call MPI_IPROBE(MPI_ANY_SOURCE, MPI_ANY_TAG,
     &                        MPI_COMM_WORLD, completed, statusmpi,ierr)
                        end if
                enddo
                !finished checking mailbox. Either our mailbox is
                !empty or we have evaluated all models
                call na_walltime(timedouble2)
                tmpiall = tmpiall + (timedouble2 - timedouble1)

                t1 = cputime(t2,t3)
                tnat = tnat + t2
                
                ! we got numMailboxEntires new samples
                if(debug) then 
                  write(*,*) 'OK, got ',numMailboxEntries,' letters'
                endif
                ns = numMailboxEntries 
                ntot0 = ntot - numMailboxEntries
                
                if(ns.gt.0) then 
                    call NA_misfits
     &                  (misfit,ns,it,ntot0,mfitmin,
     &                  mfitminc,mfitmean,mopt,
     &                  nr,work_NA2,
     &                  iwork_NA1,iwork_NA2,mfitord)
                    t1 = cputime(t2,t3)
                    tmis = tmis + t2
                    tnat = tnat + t2
                end if
                
                iitmp = int(ntot/nsample)
                iitmp2 = int(ntot0/nsample)
                if(iitmp.gt.iitmp2) then
                  it = it+(iitmp-iitmp2)
                end if

                ! Modified by dwhipp to not continue writing screen output when
                ! waiting for the final set of forward models to complete
                if (lroot .and. ns .gt. 0) then
                   r_pctfinished = (100.0*ntot) / numberOfModels 
                   write(*,*)'  ',r_pctfinished,'% completed'
                end if
        enddo
    
        ! remember what time we finished
        call na_walltime(tendTime)
        
        if(lroot) write(*,*)'FINISHED MAIN OPTIMIZATION LOOP IN NAMPIP'
  

        if(summary.and.lroot)then

        write(*,*)' '
        write(*,*)' '
        write(*,*)' '
        write(*,*)'Performance statistics'
        write(*,*)' '
        write(*,*)'Total number of full dlist evaluations',ncald
        write(*,*)'Total number of partial dlist updates ',nupd
        write(*,*)'Lowest misfit found                   ',mfitmin
        write(*,*)'Average misfit over all models        ',mfitmean
        write(*,*)'Index of lowest misfit model          ',mopt
        write(*,*)
        write(lu_sum,*)
        write(lu_sum,*)
        write(lu_sum,*)
        write(lu_sum,*)'Performance statistics'
        write(lu_sum,*)' '
        write(lu_sum,*)
     &  'Total number of full dlist evaluations  ',ncald
        write(lu_sum,*)
     &  'Total number of partial dlist updates   ',nupd
        write(lu_sum,*)
     &  'Lowest misfit found                     ',mfitmin
        write(lu_sum,*)
     &  'Average misfit over all models          ',mfitmean
        write(lu_sum,*)
     &  'Index of lowest misfit model            ',mopt
        write(lu_sum,*)

        write(lu_sum,*)
     &  'Total cpu time spent partially updating dlist      ',tupt
        write(lu_sum,*)
     &  'Total cpu time spent evaluating dlist              ',tcdt
        write(lu_sum,*)
     &  'Total cpu time spent finding Voronoi intersections ',taxist
        write(lu_sum,*)
     &  'Total cpu time spent calculating random deviates   ',tdevt
        write(lu_sum,*)
     &  'Total cpu time resetting random walks              ',trest
        write(lu_sum,*)
     &  'Total cpu time for ordering misfits                ',tmis
        if(nproc.gt.1)write(lu_sum,*)
     &  'Total elapsed time for MPI calls                   ',tmpiall
        write(lu_sum,*)
     &  'Total elapsed wall time for fwd                ',ttfwdelapsed
        write(lu_sum,*)
     &  'Total cpu time for NA-algorithm (without forward)  ',tnat
        write(lu_sum,*)
     &  'Total cpu time for forward modeling                ',ttfor
        write(lu_sum,*)
     &  'Total elapsed time for entire NA               ',
     &                          (tendTime-tstartTime)
        write(lu_sum,*)


        write(*,*)
     &  'Total cpu time spent partially updating dlist         ',tupt
        write(*,*)
     &  'Total cpu time spent evaluating dlist              ',tcdt
        write(*,*)
     &  'Total cpu time spent finding Voronoi intersections ',taxist
        write(*,*)
     &  'Total cpu time spent calculating random deviates   ',tdevt
        write(*,*)
     &  'Total cpu time resetting random walks              ',trest
        write(*,*)
     &  'Total cpu time for ordering misfits                ',tmis
        if(nproc.gt.1)write(*,*)
     &  'Total elapsed time for MPI calls                   ',tmpiall
        write(*,*)
     &  'Total elapsed wall time for fwd                ',ttfwdelapsed
        write(*,*)
     &  'Total cpu time for NA-algorithm (without forward)  ',tnat
        write(*,*)
     &  'Total cpu time for forward modeling                ',ttfor
        write(*,*)
     &  'Total elapsed time for entire NA               ',
     &                          (tendTime-tstartTime)
        write(*,*)

        end if

        
c						transform all models
c						back to scaled units
        do i=1,ntot
           ii = 1 + (i-1)*nd
           call transform2raw
     &          (na_models(ii),nd,range,scales,na_models(ii))
        end do

        nh = 1
        
c						call user supplied I/O routine
        if(lroot)call writemodels 
     &       (nd, ntot, na_models, misfit,
     &        nsamplei, nsample, itmax, nh_max, nh, header)

c                                               write out ensemble of models
c                                               as a direct access file
        
c						add NA-info to begining
c						of header file
c
        fnme = 'NA/na.nad'
        if(lroot)call NA_header
     &       (lu_nad,fnme,header,nh_max,nh,nd,
     &        range,scales,nsamplei,nsample,ncells,nh_user)

c
        if(summary.and.lroot)then
           write(*,*)' Total length of header in (nad) direct ',
     &               ' access model file = ',nh
           write(*,*)
           write(*,*)' Writing direct access file...'
           write(*,*)
        end if
c                                               write direct access nad file
 
        fnme = 'NA/na.nad'
        if(lroot)call write_nad
     &       (lu_nad,fnme,nd,ntot,
     &        nh,nh_user,header,1,na_models,misfit)

c						
c						Close NA summary file
c
        if(lroot)close(lu_sum)
        if(lroot)close(lu_det)
        if(lroot)close(lu_sob)
        if(calcmovement.and.lroot)close(lu_dis)
c						Advise of files created
        if(lroot)then

        write(*,*)
        write(*,*)' Files created:'
        write(*,*)
        write(*,*)
     &  ' na.nad : Direct access file containing ensemble of models ' 
        write(*,*)
     &  ' na.sum : Short summary file of progress' 
        if(verbose)write(*,*)
     &  ' na.det : Full details of progress' 
        write(*,*)

        end if
c
 100    format(/1x,35('-')/
     &          1x,'|',33x,'|'/
     &          1x,'|',5x,'Parameter space search',6x,'|'/,
     &          1x,'|',' using a Neighbourhood Algorithm ','|'/
     &          1x,'|',33x,'|'/
     &          1x,35('-')/)
 
       

        !Now, the MPI documentation specifies that it is 
        !*incorrect* to call MPI_Finalize with pending messages 
        !or non-empty queues, so what else can we do but abort?
        
        if(lroot) then
            call na_printnow("")
            call na_printnow("")
            call na_printnow("Please wait while I clean-up.....")
            call na_printnow("(this may take a while)")
            call na_printnow("")
            call na_printnow("")
            call na_printnow("")
        end if
        call MPI_BARRIER(MPI_COMM_WORLD, ierr)
        call MPI_Finalize(ierr)
        return

        end
#endif





c
c ----------------------------------------------------------------------------
c
c       NA_options - reads in all input options for NA algorithm.
c
c       Calls no other routines.
c
c	Comments:
c                This routine assumes that direct access
c                files are opened with the record length specified
c                in bytes. This is the default for most machines
c                but not Dec machines. (Often a compiler option is
c                available on the DEC/compaq to use bytes rather than 
c                4-byte words.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_options
     &             (nsleepMax, nd, nsamplei, nsample, istype, 
     &              noforward, nsleep, ncells, itmax, monte, nclean)
       
#if NA_F77_COMPATIBILITY
        include 'na_param.inc'
#endif
       
        integer         nsleepMax
        logical         monte
        logical         verbose
        logical         summary
        logical         timing
        logical         debug
        logical         sobol
        logical         noforward
        logical         lroot

        character       yesorno

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

        common/randomtype/sobol,iseed

        common /NAMPI/iproc,nproc,lroot
c
c                                               Write header to summary file.
        if(lroot)write(lu_sum,300)
c
c                               Question and answer session
c                               to read in NA options.
        do i=1,3
           read(lu_na,*)
        end do
c                                               Note: logical unit for reading
c                                               in NA options (lu) may be set
c                                               to the screen (5) or a file.
c
        read(lu_na,*)itype
        monte = .false.
        if(itype.eq.1)then
           monte = .true.
        else if(itype.eq.0)then
c          shrink = .true.
c       else if(itype.eq.-1)then
c          shrink = .false.
        else
           write(*,*)' Error - in NA options file' 
           write(*,*)'         Invalid algorithm type entered ' 
           write(*,*)
           call abort
        end if
c
c       write(lu_out,*)' Enter maximum number of iterations'
        read(lu_na,*)itmax
c
c       write(lu_out,*)' Enter sample size for initial population'
        read(lu_na,*)nsamplei
c
c       write(lu_out,*)' Enter sample size for remaining populations'
        read(lu_na,*)nsample
c
c       write(lu_out,*)' Enter number of models for re-sampling '
c       write(lu_out,*)' (1=only re-sample cell with lowest misfit)'
c       write(lu_out,*)' (n=re-sample best n cells)'
        read(lu_na,*)ncells

c       write(lu_out,*)' Enter length of walk from node before'
c    &                 ,' acceptance'
c       read(lu_na,*)nsleep
        nsleep = 1

c					removed option from input
c
c       write(lu_out,*)' Use Sobol-Antanov-Saleev ',
c    &                 'quasi-random sequence ?'
c       write(lu_out,*)' Enter y and idummy for SAS'
c       write(lu_out,*)' or    n and iseed for pseudo-random',
c    &                 ' sequence'
        yesorno = 'Y'
        read(lu_na,fmt='(a1,1x,i7)')yesorno,iseed
        sobol = .false.
        if(iseed.lt.0)then
           iseed = -iseed
        end if
        if(yesorno.eq.'y'.or.yesorno.eq.'Y')sobol=.true.
c
c					read initial sample type
        read(lu_na,*)istype
        noforward = .false.
        if(istype.lt.0)then
           istype = -istype
           noforward = .true.
        end if
c
c					read in size of initial 
c					sample from nad file
        if(istype.eq.1)then

           len = 4
           open(lu_nad,file='NA/na.nad',status='old',
     &          form='unformatted',access='direct',recl=len,err=20)
           read(lu_nad,rec=1)mul
           close(lu_nad)

           if(mul.gt.0)then
c                                               we are in single record format
             len = 16
             open(lu_nad,file='NA/na.nad',status='old',
     &            form='unformatted',access='direct',recl=len,err=20)
             read(lu_nad,rec=1)nd_nad,nsamplei,nh,nhu
           write(*,*)' nsamplei = ',nsamplei
             mul = 0
             close(lu_nad)

           else
c                                               we are in multi record format
             len = 20
             open(lu_nad,file='NA/na.nad',status='old',
     &            form='unformatted',access='direct',recl=len,err=20)
             read(lu_nad,rec=1)mul,nd_nad,nsamplei,nh,nhu
             mul = -mul
             close(lu_nad)
             iform = 1
           end if

           if(nd_nad.ne.nd)then
             write(*,*)
             write(*,*)' Error detected in reading starting models',
     &                ' from NAD file'
             write(*,*)
             write(*,*)' Dimension of parameter space obtained'  
             write(*,*)' from user provided subroutine user_init'  
             write(*,*)' differs from that read in from NAD file'  
             write(*,*)
             write(*,*)' Perhaps this is the wrong NAD file ?'
             write(*,*)' or user subroutine is in error ?'
             write(*,*)
             write(*,*)' Remedy: correct input NAD file or'
             write(*,*)'         user_init and recompile'
             write(*,*)
             call abort
           end if

           go to 21
 20           write(*,*)
              write(*,*)' Error detected in reading starting models',
     &                  ' from NAD file'
              write(*,*)
              write(*,*)' Cannot open file NA/na.nad'
              write(*,*)' does it exist ?'
              write(*,*)
              write(*,*)' Remedy: ensure correct input NAD file'
              write(*,*)'         is available for reading in'
              write(*,*)
              call abort
 21        continue

        end if

        ntotal = nsamplei + nsample*itmax
c
c					removed option from input
c
c       write(lu_out,*)' Enter frequency of re-initializing',
c    &                 ' distance list (per sample)'
c       write(lu_out,*)' (If the sample size is equal to 100'
c       write(lu_out,*)'  a value of 1 is usually adequate. '
c       write(lu_out,*)'  This will mean that the distance list'
c       write(lu_out,*)'  is re-initialized before each new'
c       write(lu_out,*)'  of samples is generated.'
c       write(lu_out,*)'  The smaller this parameter the less rounding' 
c       write(lu_out,*)'  error will effect nearest neighbour solution'
c       write(lu_out,*)'  but at the cost of increased computation.)'
c       read(lu_na,*)nclean
        nclean = 500

#if NA_F77_COMPATIBILITY
        nsam=max(nsample, nsamplei)
        if(nsam.gt.nsample_max)then
          write(lu_out,200)
          write(lu_out,*)' Size of sample is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' nsample          = ',nsam
          write(lu_out,*)' maximum          = ',nsample_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease sample size or'
          write(lu_out,*)'         increase parameter nsample_max'
          write(lu_out,*)'         and recompile'
          write(lu_out,*)' '
          call abort
        else if(ntotal.gt.nmod_max)then
          write(lu_out,200)
          write(lu_out,*)' Number of models is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' ntotal           = ',ntotal
          write(lu_out,*)' maximum          = ',nmod_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Increase maximum number '
          write(lu_out,*)'         of iterations and recompile'
          write(lu_out,*)' '
          call abort
        else if(itmax.gt.nit_max)then
          write(lu_out,200)
          write(lu_out,*)' Number of iterations is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' Number requested = ',itmax
          write(lu_out,*)' maximum          = ',nit_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease number of iterations '
          write(lu_out,*)'         or increase parameter nit_max'
          write(lu_out,*)'         and recompile'
          write(lu_out,*)' '
          call abort
        end if
#endif


          
        
c       write(lu_out,*)' Use verbose mode ? (y/n)'
c       write(lu_out,*)' (Gives extra information per iteration)'
        read(lu_na,*)infolevel
        verbose = .false.
        summary = .false.
        if(infolevel.eq.1)summary=.true.
        if(infolevel.eq.2)summary=.true.
        if(infolevel.eq.2)verbose=.true.

c       write(lu_out,*)' Turn timing on ? (y/n)'
        read(lu_na,fmt='(a1)')yesorno
        timing = .false.
        if(yesorno.eq.'y'.or.yesorno.eq.'Y')timing=.true.

c       write(lu_out,*)' Turn debug mode on ? (y/n)'
c       write(lu_out,*)' (Gives full information)'
        read(lu_na,fmt='(a1)')yesorno
        debug = .false.
        if(yesorno.eq.'y'.or.yesorno.eq.'Y')debug=.true.
c
c						perform parameter checking
        nsam = max(nsample,nsamplei)
        
        if(ncells.gt.nsample.or.ncells.gt.nsamplei)then
          write(lu_out,200)
          write(lu_out,*)' Number cells to be re-sampled at each'
          write(lu_out,*)' iteration is greater than the sample size'
          write(lu_out,*)' Initial sample size  = ',nsamplei
          write(lu_out,*)' Sample size          = ',nsample
          write(lu_out,*)' Re-sample size       = ',ncells
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease number of re-sampled cells'
          write(lu_out,*)'         or increase sample size'
          write(lu_out,*)' '
          call abort 
        else if(nsleep.gt.nsleepMax)then
          write(lu_out,200)
          write(lu_out,*)' Number of sleep steps is',
     &                   ' greater than the maximum.'
          write(lu_out,*)' nsleep          = ',nsleep
          write(lu_out,*)' maximum         = ',nsleep_max
          write(lu_out,*)' '
          write(lu_out,*)' Remedy: '
          write(lu_out,*)'         Decrease size of input'
          write(lu_out,*)'         variable nsleep or increase'
          write(lu_out,*)'         parameter nsleep_max and recompile'
          write(lu_out,*)' '
          call abort 
        end if
        if(istype.gt.2.or.istype.lt.0)then
          write(lu_out,200)
          write(lu_out,*)' Type of initial sample not recognized'
          write(lu_out,*)
          write(lu_out,*)' Input parameter appears to be :',istype
          write(lu_out,*)
          write(lu_out,*)' Only values 0, 1 and -1 currently supported'
          write(lu_out,*)
          write(lu_out,*)' type 0  = randomly generated internally'
          write(lu_out,*)' type 1  = read in from a NAD file '
          write(lu_out,*)' type -1 = same as 1 but perform forward',
     &                     ' modelling of initial sample'
          write(lu_out,*)
          call abort
        end if
             
c
c                            Display NA options
c
        if(lroot)then

                


        write(lu_sum,100)
        write(lu_sum,fmt='("  Options set:"/)')
        if(monte)then
#if defined NA_MPI
           write(lu_sum,*)' Uniform Monte Carlo Algorithm using MPI'
#else
           write(lu_sum,*)' Uniform Monte Carlo Algorithm'
#endif
        else
#if defined NA_MPI
           write(lu_sum,*)' Neighbourhood Algorithm using MPI'
#endif
#if defined NA_MPIP
           write(lu_sum,*)' Continuous Neighbourhood Algorithm with MPI'
#else
           write(lu_sum,*)' Neighbourhood Algorithm'
#endif
        end if
        write(lu_sum,*)' Initial sample size           : ',nsamplei
        write(lu_sum,*)' Sample size                   : ',nsample
        write(lu_sum,*)' Total number of iterations    : ',itmax
c       write(lu_sum,*)' Number of axis samples        : ',naxis
c       write(lu_sum,*)' Number of samples per reset   '
c       write(lu_sum,*)' of distance database          : ',nclean
        write(lu_sum,*)' Number of cells re-sampled    : ',ncells
        write(lu_sum,*)' Total number of models        : ',ntotal
c       write(lu_sum,*)' Length of walk in cell        : ',nsleep
        write(lu_sum,*)' Random seed value             : ',iseed 
        if(sobol)then
           write(lu_sum,*)' SAS Quasi-random sequence used'
        else
           write(lu_sum,*)' Pseudo-random sequence '
        end if
        if(istype.eq.1)then
           write(lu_sum,*)' Starting models read in from NAD file'
        else if(istype.eq.2)then
           write(lu_sum,*)' Starting models specified by user'
        else
           write(lu_sum,*)' Starting models generated randomly '
        end if
        write(lu_sum,100)
c
        if(summary)then

        write(lu_out,100)
        write(lu_out,fmt='("  Options set:"/)')
        if(monte)then
#if defined NA_MPI
           write(lu_out,*)' Process                       : ',
     &                    'Uniform Monte Carlo with MPI'
#else
           write(lu_out,*)' Process                       : ',
     &                    'Uniform Monte Carlo'
#endif
        else
#if defined NA_MPI
           write(lu_out,*)' Process                       : ',
     &                    'Neighbourhood Algorithm with MPI'
#endif
#if defined NA_MPIP
           write(lu_out,*)' Process                       : ',
     &                    'Continuous Neighbourhood Algorithm with MPI'
#else
           write(lu_out,*)' Process                       : ',
     &                    'Neighbourhood Algorithm'
#endif
        end if
        write(lu_out,*)' Initial sample size           : ',nsamplei
        write(lu_out,*)' Sample size                   : ',nsample
        write(lu_out,*)' Total number of iterations    : ',itmax
c       write(lu_out,*)' Number of axis samples        : ',naxis
c       write(lu_out,*)' Number of samples per reset   '
c       write(lu_out,*)' of distance database          : ',nclean
        write(lu_out,*)' Number of cells re-sampled    : ',ncells
        write(lu_out,*)' Total number of models        : ',ntotal
c       write(lu_out,*)' Length of walk in cell        : ',nsleep
        write(lu_out,*)' Random seed value             : ',iseed 
        if(sobol)then
           write(lu_out,*)' SAS Quasi-random sequence used'
        else
           write(lu_out,*)' Pseudo-random sequence used'
        end if
        if(istype.eq.1)then
           write(lu_out,*)' Starting models read in from NAD file'
        else if(istype.eq.2)then
           write(lu_out,*)' Starting models specified by user'
        else
           write(lu_out,*)' Starting models generated randomly '
        end if
        write(lu_out,100)

        end if

        end if
c

        if(verbose.and.lroot)then
           open(lu_det,file='na.det',status='unknown')
           write(lu_det,100)
           write(lu_det,*)' Details of each iteration'
           write(lu_det,100)
        end if

c
 100    format(/,72("-")/)
 200    format(/' Error in input options for NA'/)
 300    format(/3x,"Summary information of Neighbourhood",
     &             " algorithm performance")

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_initialize - performs minor initialization tasks for NA algorithm.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_initialize
     &             (range,ranget,scales,numberOfModels,misfit,na_models,
     &              nd,x,nsample,ncells,restartNA)
c
#if NA_F77_COMPATIBILITY
        include 'na_param.inc'
#endif
#if NA_MPI
        include "mpif.h"
#endif
        integer nd, nsample, ncells
        real            range(2,nd)
        real            ranget(2,nd)
        real            scales(*)
        real            x(nd)
        real            rval(2)
        real            misfit(*)
        real            na_models(*)

        logical         restartNA
        logical         sobol
        logical         verbose
        logical         summary
        logical         timing
        logical         debug
        logical         lroot
 
        common /NAMPI/iproc,nproc,lroot

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary
        common /NA_init/idnext,ic
        common/randomtype/sobol,iseed


#if NA_F77_COMPATIBILITY
        if(nd.gt.nd_max)then
           write(*,400)nd,nd_max
           call abort
        end if
#endif


c                                               Initialize some arrays
        do i=1,nd*numberOfModels
            na_models(i) = 0.
        end do
        do i=1,numberOfModels
            misfit(i) = 0.
        end do

c						set logical switch for 
c						first call to NA_sample 
c						(ensures distance list is
c						 initialized)
        restartNA = .true.
c
c						set initial parameter
c						for NA walk
c	idnext = 1
        ic = 1

        if(sobol)then
c                                               Initialize 1-D Sobol sequence
c						to control initial dimension 
c						in NA random walk
c          call sobseq(-2,rval)
           call sobseq(-1,rval)
c						Initialize pseudo-random 
c						number generator
           iseed0 = iseed
           a = ran3(iseed0)
c						open file for sas coefficients
c
           if(lroot)open(lu_sob,file='sobol.coeff',status='unknown')

c						Generate coefficients
c						for quasi-random 
c						multi-dimensional SAS sequence
c
           call NA_sas_table(nd*ncells,lu_sob)

#if NA_MPI
c						need to sync here so that
c						all processes can read a
c						file in NA_sobol
           call MPI_BARRIER(MPI_COMM_WORLD, ierr)
#endif

           if(lroot)close (lu_sob)
c                                               Initialize n-D Sobol sequence

           open(lu_sob,file='sobol.coeff',status='unknown')

           call NA_sobol(lu_sob,nd*ncells,dummy,1,1)

        else
c						Initialize pseudo-random 
c						number generator
           iseed0 = iseed
           a = ran3(iseed)

        end if
c						Normalize parameter ranges
c						by a-priori model co-variances
c
        if(scales(1).eq.0.0)then
c						First option:
c						No transform 
c						(All a priori model 
c						 co-variances are 
c						 equal to unity)
           do i=1,nd
              ranget(1,i) = range(1,i)
              ranget(2,i) = range(2,i)
              scales(i+1) = 1.0
           end do

        else if(scales(1).eq.-1.0)then
c						Second option:
c						Use parameter range as
c						a priori model co-variances 
           do i=1,nd
              ranget(1,i) = 0.0
              ranget(2,i) = 1.0
              scales(i+1) = range(2,i)-range(1,i)
           end do

        else
c						Third option:
c						Use scales array as
c						a priori model co-variances 
           do i=1,nd
              if(scales(i+1).eq.0.0)then
                 write(*,200)i
                 call abort
              end if
              ranget(1,i)  = 0.0
              ranget(2,i)  = (range(2,i)-range(1,i))/scales(i+1)
           end do

        end if
c						calculate axis increments
c                                               and initialize current point
c                                               (used by NA_sample) to
c                                               mid-point of parameter space

        do i=1,nd
           x(i) = (ranget(2,i)+ranget(1,i))/2.0
c          x(i) = 0.0
        end do
        
c						write out information
c						on parameter space
c						to summary file
        if(lu_sum.gt.5.and.lroot)then
           
c       write(lu_sum,300)
        write(lu_sum,fmt='("Parameter space details:"/)')
        write(lu_sum,*)' Number of dimensions           : ',nd
        write(lu_sum,*)' '
        write(lu_sum,*)' Parameter ranges'
        write(lu_sum,*)'   Number   Minimum     Maximum   ',
     &                    ' A-prior cov Scaled min  Scaled max'
c
        do i=1,nd
           if(scales(1).eq.0.0)then
              sf = 1.0 
           else if(scales(1).eq.-1.0)then
              sf = range(2,i)-range(1,i)  
           else
              sf = scales(i+1)
           end if
           write(lu_sum,100)i,range(1,i),range(2,i),sf,
     &                      ranget(1,i),ranget(2,i)
        end do
        write(lu_sum,300)

        end if

 100    format(3x,i4,2x,5(f11.4,1x))
 200    format(/' Error in subroutine NA_initialize '//,
     &          ' Input a priori model co-variance is equal to zero',
     &          ' for parameter ',i4/
     &          ' This is not valid'//
     &          ' Remedy - check and adjust input',
     &          ' a priori co-variances'/)
 300    format(/72("-")/)

#if NA_F77_COMPATIBILITY
 400    format(/' Error in subroutine NA_initialize '//,
     &          ' Number of dimensions greater than maximum'/
     &          ' Number of dimensions needed  :',i4/
     &          ' Maximum number of dimensions :',i4//
     &          ' Remedy - increase parameter nd_max ',
     &          ' and recompile program'/)
#endif
        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_initial_sample - generates initial sample for NA algorithm.
c
c	Comments:
c
c		Assumes n-dimensional Sobol sequence has been initialized
c		Will generate a minimum of two samples.
c
c		Assumes ran3 has been initialized.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c						(Updated for ran3 Aug. 1997)
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_initial_sample
     &             (na_models,nd,range,rangeo,nsample,
     &              numberOfModels,istype,monte,calcmovement,
     &              scales,misfit)

#if NA_F77_COMPATIBILITY
        include 'na_param.inc'
#else
        parameter       (nh_max=1000, nsleep_max=1, maxseq=50)
#endif

        integer nd, nsample, numberOfModels
        real*4          na_models(nd,*)
        real*4          range(2,*)
        real*4          rangeo(2,*)
        real*4          scales(*)
        real*4          misfit(*)

        character       header(nh_max)
        character*256   fnme

        logical         sobol
        logical         verbose
        logical         summary
        logical         debug
        logical         timing
        logical         monte
        logical         calcmovement
 
        common/randomtype/sobol,iseed

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

c                                               read in starting
c                                               models from a NAD file
        if(istype.eq.1.and..not.monte)then

           fnme = 'NA/na.nad'
           call read_nad
     &          (lu_nad,fnme,nhi,nhui,iform,nd_nad,nsample,
     &           nh_max,nd,numberOfModels,
     &           header,misfit,na_models)

           do i=1,nsample
              call transform2sca
     &             (na_models(1,i),nd,rangeo,scales,na_models(1,i))
           end do

        else if(istype.eq.2.and..not.monte)then

c						read in models from
c						ascii input file
c
           open(lu_nad,file='models.in',status='old',err=33)
           k = 1
 32        read(lu_nad,*,end=34,err=33)
           read(lu_nad,*,err=33)misfit(k)
           read(lu_nad,*)(na_models(i,k),i=1,nd)
           k = k + 1
           go to 32
 33        write(*,*)' Error reading input file models.in'
           call abort
 34        continue
           close(lu_nad)
           nsample_r = k-1

c						scale models read in
           do i=1,nsample_r
              call transform2sca
     &             (na_models(1,i),nd,rangeo,scales,na_models(1,i))
           end do
c
           if(nsample_r.lt.nsample)then
c						randomly generate the
c						the remaining samples 
              nrem = nsample - nsample_r
              write(*,*)' generating remaining samples ',nrem
c						Generate initial samples
c						using quasi random sequences
              if(sobol)then
                 do i=nsample_r+1,nsample
                    do j=1,nd
                       call NA_sobol(ldummy,j,na_models(j,i),1,0)
                       a = na_models(j,i)
                       b = 1-a
                       na_models(j,i) = b*range(1,j) + a*range(2,j)
                    end do
                 end do
              else
c						Use pseudo random 
c						number generator ran3 
                 do i=nsample_r+1,nsample
                    do j=1,nd
                       a = ran3(iseed)
                       b = 1-a
                       na_models(j,i) = b*range(1,j) + a*range(2,j)
                    end do
                 end do
              end if

           end if

        else
c						Generate initial uniform
c						random sample using a
c                                               uniform random distribution

c						Generate initial samples
c						using quasi random sequences
           if(sobol)then
              do i=1,nsample
                 do j=1,nd
                    call NA_sobol(ldummy,j,na_models(j,i),1,0)
                    a = na_models(j,i)
                    b = 1-a
                    na_models(j,i) = b*range(1,j) + a*range(2,j)
                 end do
              end do

           else
c						Use pseudo random 
c						number generator ran3 
              do i=1,nsample
                 do j=1,nd
                    a = ran3(iseed)
                    b = 1-a
                    na_models(j,i) = b*range(1,j) + a*range(2,j)
                 end do
              end do

           end if

        end if

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_random - generates a uniform random sample to be used
c		    instead of NA algorithm.
c
c	Assumes random number generator ran3 has been initialized
c
c       Calls ran3.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_random
     &             (na_models,nd,range,ntot,nsample,calcmovement)


        real*4          na_models(nd,*),
     &                  range(2,*)

        logical         calcmovement
        logical         verbose
        logical         summary
        logical         timing
        logical         debug
        logical         sobol

        common /findnearestcom/dnear
        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary
        common/randomtype/sobol,iseed


        dsum = 0.0
c						generate samples
        do i=ntot+1,ntot+nsample

           if(sobol)then
c						use quasi-random
c						number generator
              do j=1,nd
                 call NA_sobol(ldummy,j,na_models(j,i),1,0)
                 a = na_models(j,i)
                 b = 1-a
                 na_models(j,i) = b*range(1,j) + a*range(2,j)
              end do
           else
c						use pseudo-random
c						number generator
              do j=1,nd
                 a = ran3(iseed)
                 b = 1-a
                 na_models(j,i) = b*range(1,j) + a*range(2,j)
              end do
           end if
c						find distance to 
c						nearest model
c						(for info purposes)

           if(calcmovement)then

           call findnearest(na_models(1,i),na_models,i-1,nd,nnode)

           dsum = dsum + sqrt(dnear)

           end if

        end do

c						write out average distance
c						of population from current
c						best model
        if(calcmovement)then
           write(lu_dis,*)ntot+nsample,dsum/real(nsample)
        end if

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_sas_table - uses a pseudo random number generator to
c		       build the initializing data for the quasi
c		       random SAS sequence.
c
c	Input:
c	nt			Number of sequences to be generated 
c	lu			A vacant logical unit for writing out
c				SAS initializing data to a file
c	Output:
c				table written to file sobol.coeff
c	
c	Comments:
c
c	This routine generates initializing data for multiple
c       Sobol-Antonov-Saleev quasi-random sequences. For each 
c	sequence a degree and order of the primitive polynomial 
c	are required, and here they are determined by a particular
c	formula (below).
c	
c	The degree, order and initializing random data for each SAS sequence, 
c	are written to a file, the free values have been generated 
c	randomly (under-constraints) using ran3 from Numerical Recipes. 
c	
c	For each degree and order pair (q,p) q initializing integers are 
c	required for each sequence, (M1, M2, ..., Mq), where
c	Mi may be any odd integer less than 2**i. So
c	for the i-th term, there are 2**(i-1) possible values. We write,
c	
c               Nq = 2**(i-1).
c	
c	Since each initializing datum is independent, the total number 
c	of possible sequences for degree q is the product,
c
c               Ntotal =  N1 x N2 x N3 x ... Nq,
c
c	which gives,
c
c               Ntotal = prod (for i=1,...,q) 2**(i-1),
c
c               Ntotal = 2**[sum(for i=1,...,q) (i-1))]
c
c               Ntotal = 2**(q*(q-1)/2)
c
c	Which gives,
c
c       q           Ntotal      Nq   Number of primitive polynomials (Np)
c       1                1       1            1
c       2                2       2            1
c       3                8       4            2
c       4               64       8            2
c       5             1024      16            6
c       6            32768      32            6
c       7          2097152      64           18
c       8        268435456     128           16
c       9     6.8719476E10     256           48
c      10     3.5184372E13     512           60
c
c
c	Note the number of possible primitive polynomial orders (Np)
c	and their values are defined the degree. 
c	All possible values of polynomial order for degrees up to 10 are
c	contained in the array pporder.
c	(A table can also be found on p 302 of Numerical Recipes in 
c	Fortran 2d Ed. Press et al 1992)
c	The product of Np and Ntotal is the total number of possible 
c 	sequences for that degree.
c
c	When generating a large number of independent sequences using randomly
c	generated initializing data it is prudent to use only higher degrees
c	because for, say degree 4 there are only 64 possible sequences for 
c	each of the two polynomial order values, and so
c	if more than 64 are generated some will be duplicates and hence
c	will produce identical (and not independent) sequences.
c
c	Array pporder contains all possible primitive polynomial orders
c	for each degree up to 10.
c
c	The particular formula used here to choose degree and polynomial
c	order for each independent sequence is to cycle through each degree
c	(starting from 5) and take ntotal/10 sequences from that degree.
c	Once the degree is chosen, the polynomial order cycles through
c	its possible values (given by array pporder). The objective here
c	is to minimize the likelihood of repeated trials with different
c	random seeds reproducing the same sequence. Remember there are 
c	a finite number of sequences for each degree (see above).
c
c       Calls ran3 and assumes that this pseudo random number generator 
c	has been initialized.
c
c						M. Sambridge, Aug. 1999
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_sas_table(nt,lu)

        
        parameter(maxdeg=10)

        integer         a(maxdeg)
        real*8          ntot(10)
        integer         nprim(10)
        integer         pporder(60,10)
        logical         sobol

        logical         lroot

        common /NAMPI/iproc,nproc,lroot

        data            ntot/1.,2.,8.,64.,1024.,32768.,2097152.,
     &                       268435456.,6.8719476E10,3.5184372E13/
        data            nprim/1,1,2,2,6,6,18,16,48,60/
        data            pporder/0,59*0,
     &                  1,59*0,
     &                  1,2,58*0,
     &                  1,4,58*0,
     &                  2,4,7,11,13,14,54*0,
     &                  1,13,16,19,22,25,54*0,
     &                  1,4,7,8,14,19,21,28,31,32,
     &                  37,41,42,50,55,56,59,62,42*0,
     &                  14,21,22,38,47,49,50,52,56,67,
     &                  70,84,97,103,115,122,44*0,
     &                  8,13,16,22,25,44,47,52,55,59,
     &                  62,67,74,81,82,87,91,94,103,104,
     &                  109,122,124,137,138,143,145,152,
     &                  157,167,173,176,181,182,185,191,
     &                  194,199,218,220,227,229,230,234,
     &                  236,241,244,253,12*0,
     &                  4, 13, 19, 22, 50, 55, 64, 69, 
     &                  98, 107, 115, 121, 127, 134, 140, 
     &                  145, 152, 158, 161, 171, 181, 194, 
     &                  199, 203, 208, 227, 242, 251, 253, 
     &                  265, 266, 274, 283, 289, 295, 301, 
     &                  316, 319, 324, 346, 352, 361, 367, 
     &                  382, 395, 398, 400, 412, 419, 422, 
     &                  426, 428, 433, 446, 454, 457, 472, 
     &                  493, 505, 508/

        common/randomtype/sobol,iseed

c	do i=1,10
c	   write(lu,*)(pporder(j,i),j=1,60)
c	end do
c       nt = 0
c       nl = 0
c       do i=1,19
c         read(10,*)
c       end do
c

        a(1) = 1
        if(lroot)write(lu,100)
        if(lroot)write(lu,101)nt
        if(lroot)write(lu,103)
        if(lroot)write(lu,102)iseed
c                                               choose degree, order and
c                                               number of independent
c                                               sequences to be generated
c						using malcolm's formula
c						defined above
        ii = 0
c          read(10,*)mdeg,ip,num
        do mdeg=5,10
           if(mdeg.gt.maxdeg)pause 'too many degrees'
           numt = int(ntot(mdeg)/100)
           do num=1,numt
              is = mod(num,nprim(mdeg))+1
              ip = pporder(is,mdeg) 
              ii = ii + 1
              do j=2,mdeg
                 rval = ran3(iseed)
                 m = 2**(j-1)
                 a(j) = 2*(1+int(m*rval))-1
              end do
              if(lroot)
     &        write(lu,*)' ',mdeg,'   ',ip,'    ',(a(j),j=1,mdeg)
              if(ii.eq.nt)go to 99
           end do
        end do
  99    continue
c
 100    format('% Initializing data for multi-dimensional',
     &             ' Sobol-Antonov-Saleev'/
     &             '% sequence generated randomly by routine ',
     &             'NA_sas_table'/
     &             '%'/'% The number of initializing values must be',
     &             ' equal to the degree '/
     &             '% and the i-th value is any',
     &             ' odd integer < 2**i'/'%')
 103    format('%'/
     &             '% Be careful not to generate too many sequences'/
     &             '% with low degree say < 5  because some may be'/
     &             '% identical due to the limited number of',
     &             ' possibilities'/'%'/
     &             '% The number of possible independent sequences',
     &             ' is defined by the table'/'%'/
     &             '% DEG : 1  2  3   4    5     6       7',
     &             '         8            9           10'/
     &             '% N   : 1  2  8  64 1024 32768 2097152 268435456',
     &             ' 6.8719476E10 3.5184372E13'/'%')

 101    format(1x,i8,12x,'maximum number of independent sequences')
 102    format('%',15x,'random seed used =',i10/
     &         '% deg   poly    Initializing values')


        return
        end
c
c-----------------------------------------------------------------------
c
c	NA_sobol - Adaptation of numerical recipes routine for 
c		   generating a Sobol-Antonov-Saleev sequence 
c		   in n-dimensions.
c
c       Routine must be initialized by a first call with init = 1.
c       Initializing data is then read in from file `sobol.in' 
c	for each independent sequence. 
c
c       If mode = 0:
c       then an n-dimensional vector of independent quasi random deviates
c       is generated. The value of n should not be changed after
c       initialization.
c
c       If mode .ne. 0:
c       then n independent sequences are initialized
c       but each call generates the next value of the
c       nth-sequence, i.e. not all n are generated at once and different
c       numbers of deviates can be generated from each sequence. After
c       initialization n represents the sequence number for the next deviate
c       and may be any value between 1 and the n used for initialization.
c
c	Maximum number of random sequences read in from unclude file
c
c       The input parameter mode is used at initialization and must 
c	not be changed after initialization.
c
c					M. Sambridge, RSES, July 1998.
c
c-----------------------------------------------------------------------
c
      SUBROUTINE NA_sobol(lu,n,x,mode,init)
      INTEGER n,MAXBIT,MAXSEQ
      REAL x(*)
c
#if NA_F77_COMPATIBILITY
        include 'na_param.inc'
#else
        parameter       (nh_max=1000, nsleep_max=1, maxseq=50)
#endif
c
c     PARAMETER (MAXBIT=30,MAXSEQ=160)
      PARAMETER (MAXBIT=30)
      INTEGER i,im,in,ipp,j,k,l,ip(MAXSEQ),iu(MAXSEQ,MAXBIT),iv(MAXBIT*
     *MAXSEQ),ix(MAXSEQ),mdeg(MAXSEQ),inn(MAXSEQ)
      REAL fac
      SAVE ip,mdeg,ix,iv,in,fac,inn
      EQUIVALENCE (iv,iu)
c
      common/nab_IO/silent,verbose,debug
      logical           debug
      logical           verbose
      logical           silent

      if (init.eq.1) then
c                                               read in data
        do i=1,6
          read(lu,*)
        end do
        read(lu,*)nn
        do i=1,12
          read(lu,*)
        end do
        if(n.gt.MAXSEQ)then
           write(*,*)
           write(*,*)' Error in subroutine NA_sobol'
           write(*,*)' Too many random sequences required'
           write(*,*)' Current maximum dimension ',MAXSEQ
           write(*,*)' Number requested          ',n
           write(*,*)
           write(*,*)' Remedy: increase parameter MAXSEQ'
           write(*,*)'         and recompile'
           write(*,*)
           call abort
        end if
        if(n.gt.nn)then
           write(*,*)
           write(*,*)' Error in subroutine NA_sobol'
           write(*,*)' Not enough initializing data in input file'
           write(*,*)' Number of sequences in data file       ',nn
           write(*,*)' Number requested                       ',n
           write(*,*)
           write(*,*)' Remedy: Initializing data is generated'
           write(*,*)'         automatically so there must be a bug'
           write(*,*)'         somewhere. Contact an expert quickly.'
           write(*,*)
           call abort
        end if
        do i=1,n
           read(lu,*)mdeg(i),ip(i),(iu(i,j),j=1,mdeg(i))
        end do
        if(debug)then
           write(*,*)' NA_sobol read in initializing data for',
     &               n,' quasi-random sequences' 
        end if

        do i=1,MAXSEQ
           ix(i) = 0
        end do

        do 14 k=1,MAXSEQ
          do 11 j=1,mdeg(k)
            iu(k,j)=iu(k,j)*2**(MAXBIT-j)
11        continue
          do 13 j=mdeg(k)+1,MAXBIT
            ipp=ip(k)
            i=iu(k,j-mdeg(k))
            i=ieor(i,i/2**mdeg(k))
            do 12 l=mdeg(k)-1,1,-1
              if(iand(ipp,1).ne.0)i=ieor(i,iu(k,j-l))
              ipp=ipp/2
12          continue
            iu(k,j)=i
13        continue
14      continue
        fac=1./2.**MAXBIT

        if(mode.eq.0)then
          in=0
        else
          do i=1,n
           inn(i) = 0
          end do
        end if

      else

c                                       generate n-dimensional
c                                       quasi-deviate
        if(mode.eq.0)then

           im=in
           do 15 j=1,MAXBIT
             if(iand(im,1).eq.0)goto 1
             im=im/2
15         continue
           pause 'MAXBIT too small in sobol'
1          im=(j-1)*MAXSEQ
           do 16 k=1,min(n,MAXSEQ)
             ix(k)=ieor(ix(k),iv(im+k))
             x(k)=ix(k)*fac
16         continue
           in=in+1

        else
c                                       generate next quasi
c                                       deviate in n-th sequence
           im=inn(n)
           do 115 j=1,MAXBIT
             if(iand(im,1).eq.0)goto 100
             im=im/2
115        continue
           pause 'MAXBIT too small in sobol'
100        im=(j-1)*MAXSEQ
c          do 16 k=1,min(n,MAXSEQ)
             ix(n)=ieor(ix(n),iv(im+n))
c            x(n)=ix(n)*fac
             x(1)=ix(n)*fac
c16        continue
           inn(n)=inn(n)+1

c	   write(50,*)n,x(1) 

        end if

      endif

      return
      END
c
c ----------------------------------------------------------------------------
c
c       NA_misfits - calculate performance statistics for NA algorithm.
c
c
c       nsample is the number of new samples since NA-misfits
c       was last called
c
c       ntot is the total number of models, *excluding* the
c       latest batch of nsample ones that we are going to
c       include now.
c
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_misfits
     &             (misfit,nsample,it,ntot,mfitmin,
     &              mfitminc,mfitmean,mopt,
     &              ncells,work,ind,iwork,mfitord)
        
        real            misfit(*)
        real            mfitmin
        real            mfitmean
        real            mfitminc
        real            work(*)

        integer         ind(*)
        integer         mfitord(*)
        integer         iwork(*)

        logical         verbose
        logical         summary
        logical         timing
        logical         debug

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary

        mfitminc = misfit(ntot+1)
        mfitmean = mfitminc
        iopt = ntot+1

        do i=ntot+2,ntot+nsample
           mfitmean = mfitmean + misfit(i)
           if(misfit(i).lt.mfitminc)then
              mfitminc = misfit(i)
              iopt = i
           end if

        end do
        mfitmean = mfitmean/real(nsample)

        if(mfitminc.lt.mfitmin.or.it.eq.1)then
           mopt = iopt
           mfitmin = mfitminc
        end if

c					find mtop lowest misfits
c       write(*,*)' it       = ',it
c       write(*,*)' ntot     = ',ntot
c       write(*,*)' mfitmin  = ',mfitmin
c       write(*,*)' mfitmean = ',mfitmean
c       write(*,*)' mfitminc = ',mfitminc

c                                       find models with
c                                       lowest ncells misfit values
           if(ncells.eq.1)then

               mfitord(1) = mopt

           else 

              ntotal = ntot+nsample

              do i=1,ntotal
                 ind(i) = i
                 work(i) = misfit(i)
              end do
   
c							jumble initial indices
c							to randomize order
c							of models when misfits
c							are equal
              call jumble(ind,work,ntotal)
c
              flow = select(ncells,ntotal,work,ind,iselect)

c	      write(88,*)' flow = ',flow
c	      write(88,*)' iselect = ',iselect
c	      write(88,*)' ncells = ',ncells
c             do j=1,ntotal
c                write(88,*)' j',j,' misfit ',work(j),
c    &                     misfit(j),' ind ',ind(j)
c             end do

              do j=1,ncells
                iwork(j) = ind(j)
              end do 
c					order misfit of lowest ncells
c
              call indexx(ncells,work,ind)

              do j=1,ncells
                 mfitord(j) = iwork(ind(j))
c 		 write(88,*)' mfitord ',j,mfitord(j),misfit(mfitord(j))
              end do
c
c	      do j=1,ncells
c                k = mfitord(j)
c                write(88,*)' sorted model ',k,' misfit ',misfit(k)
c             end do

           end if

        return
        end
c
c---------------------------------------------------------------------------
c
c     NA_deviate - generates a random deviate according to
c                  a given distribution using a 1-D SAS sequence.
c		   or a pseudo-random sequence depending of logical
c		   `sobol'
c
c     Comments:
c		If sobol = .true.: (Quasi-random number)
c
c		   This routine generates a random number 
c		   between x1 and x2.
c		   The parameter i is the sequence number from 
c		   which the quasi random devaite is drawn.
c
c		If sobol = .false. (Pseduo-random number)
c
c		   ran3 is called to calculate a deviate which is
c		   scaled to the input boundaries x1,x2.
c
c		This version is for resample mode and simply generates
c		a deviate between input values x1 and x2.
c
c	        calls NA_sobol
c
c---------------------------------------------------------------------------
c
        Subroutine NA_deviate
     &             (x1,x2,i,deviate)
c
        logical         sobol
 
        common/randomtype/sobol,iseed
c							Use SAS sequence
        if(sobol)then

           call NA_sobol(ldummy,i,ran,1,0)
           deviate = x1 + (x2-x1)*ran

c	   write(50,*)' n ',n,' i',i,' j',j,' dev ',dev(i,j)

        else

           ran = ran3(iseed)
           deviate = x1 + (x2-x1)*ran

        end if

        return
        end
c
c---------------------------------------------------------------------------
c
c     NA_gen_deviates - generates uniform quasi random deviates using
c                       a Multi-dimensional Sobol-Antonov-Saleev sequence.
c
c       Input:
c	      n 		: Number of independent sequences to 
c				: be generated (one per dimension) 
c	      m 		: Number of terms in each sequence
c				: to be generated.
c       Output:
c	      dev(n,m))		: Array of deviates.
c	
c     Comments:
c		Generates all deviates required for one execution of
c		routine NA_sample and stores them in array dev. This is
c	        necessary because of the order the deviates are used
c		in NA_sample is different from that in which they 
c		can be generated. In this way it is possible to use
c	        independent multi-dimensional SAS sequences in each
c		resampled cell. Without this `in advance' approach the
c		same SAS sequence would need to be used across more
c		than one cell which introduces undesirable cyclicity in
c		the use of the samples from a single sequence.
c
c---------------------------------------------------------------------------
c
        Subroutine NA_gen_deviates 
     &                            (nd,nc,nsp,nsl,nsample,dev)
        real            dev(nd*nc,*)
        logical         sobol

        common/randomtype/sobol,iseed
 
        nrem = mod(nsample,nc)

        n = nd*nc
        m = nsp*nsl
        n1 = nd*nrem
        n2 = nd*(nc-nrem)
        m1 = nsp*nsl
        m2 = (nsp-1)*nsl

        if(sobol)then

          if(nrem.eq.0)then
             do i=1,m
                do j=1,n
                   call NA_sobol(ldummy,j,dev(j,i),1,0)
                end do
             end do
          else
             do i=1,m1
                do j=1,n1
                   call NA_sobol(ldummy,j,dev(j,i),1,0)
                end do
             end do
             do i=1,m2
                do j=n1+1,n
                   call NA_sobol(ldummy,j,dev(j,i),1,0)
                end do
             end do
          end if
        end if

c	write(50,*)' gen deviates'
c	do j=1,n
c	   write(50,*)j,' :',(dev(j,i),i=1,m)
c	end do
c	write(50,*)

        return
        end








        
c
c ----------------------------------------------------------------------------
c
c       NA_sample - generates a new sample of models using 
c                   the Neighbourhood algorithm by distributing
c		    nsample new models in ncells cells.
c
c	Comments:
c		 If xcur is changed between calls then restartNA 
c		 must be set to true. logical restartNA must also 
c		 be set to true on the first call.
c
c       Calls are made to various NA_routines.
c
c						M. Sambridge
c						Last updated May 1999.
c
c
c  May. 2004.
c       changes made to allow NA to work in 'continuous' mode
c  June. 2004
c       changes made to allow NA to work out ncells for itself rather
c       than relying on the user. This happens if ncells is set to -1
c       Currently this only works in continuous mode with MPI.
c
c
c-----------------------------------------------------------------------
        Subroutine NA_sample
     &             (na_models, ntot, nsample, nd, nsleep, ncells,
     &              misfit, mfitord, range, 
     &              check, xcur, restartNA, 
     &              calcmovement, nclean, dlist)
        integer         nsample, nd, nsleep
        real            na_models(nd,*)
        real            range(2,*)
        real            misfit(*)

        real            xcur(*)
        real            dlist(*)
        real            xdum(100)

        integer         mfitord(*)
        integer         cell

        logical         verbose
        logical         summary
        logical         timing
        logical         debug
        logical         resetlist
        logical         check
        logical         restartNA
        logical         info
        logical         calcmovement

        logical         lroot


        common /NA_info/nxsave,ndsave,ndc,nerr,ncald,nupd,
     &                  cells,torder,taxis,tup,tcd,tdev,tna,tres

        common /NA_info_special/taxis2

        common /NA_init/idnext,ic

        common /NA_IO/lu_na,lu_out,lu_sum,lu_det,lu_sob,lu_dis,
     &                lu_nad,verbose,debug,timing,summary
        common /NAMPI/iproc,nproc,lroot

        save id

c                                               choose initial 
c                                               axis randomly
        call irandomvalue(1,nd,idnext)
c
        
        ! check whether we are in the discrete or continuous case
        ! If nsample is -ve, we are in continuous case
        if(nsample.lt.0)then
           nsample0 = 1
        else
           nsample0 = nsample
        end if
        
        ic = ic + 1
        info = .false.
        if(mod(ic,nclean).eq.0)resetlist = .true.
        if(mod(ic,nclean).eq.0.and.verbose)info = .true.
        idiff = 0
        ndc = 0
        cells = 0.0
        nxsave = 0
        ndsave = 0
        nerr = 0
        taxis = 0.0
        taxis2 = 0.0
        tup = 0.0
        tna = 0.0
        tcd = 0.0
        tdev = 0.0
        tres = 0.0
        cell = 1
        mopt = mfitord(cell)
        ind_cellnext = mopt
        ind_celllast = 0
        dsum = 0.0
        dcount = 0.0
                
        nrem = mod(abs(nsample),ncells)

        if(nrem.eq.0)then
           nsampercell = abs(nsample)/ncells
        else
           nsampercell = 1+abs(nsample)/ncells
        end if
        nsleep0 = nsleep
#ifdef NA_MPIP
        !if we are doing NAMPIP, then we pick a cell at random
        !and we also pick a walk length at random
        call irandomvalue(1, ncells, cell)
        ind_cellnext = mfitord(cell)
        call irandomvalue(1, nsampercell, nsleep0)
#endif

        if(timing)then
            t1 = cputime(t2,t3)
            tna = tna + t2
        end if 
        
        icount = 0
        if(debug)write(*,*)' nsample     = ',nsample
        if(debug)write(*,*)' nsampercell = ',nsampercell

c
c						loop over samples
        do is = 1,nsample0
c						choose Voronoi cell 
c						for sampling
           ind_cell = ind_cellnext 
           icount = icount + 1
           if(debug)write(*,*)cell,' cell = ',ind_cell
           if(ind_cell.ne.ind_celllast)then

              if(timing)then
                t1 = cputime(t2,t3)
                tna = tna + t2
              end if 
c						reset walk to 
c						chosen model
              call NA_restart
     &             (na_models,nd,ind_cell,xcur,debug,restartNA)


              if(timing)then
                t1 = cputime(t2,t3)
                tres = tres + t2
                tna = tna + t2
              end if 
           end if

           if(restartNA)then
              resetlist = .true.
              restartNA = .false.
           end if

c						loop over walk steps
           do il = 1,nsleep0
           do iw = 1,nd

c						update dlist and nodex
c						for new axis

              if(.not.resetlist)then
                 if(timing)then
                    t1 = cputime(t2,t3)
                    tna = tna + t2
                 end if
c                                               incremental update
                 call NNupdate_dlist
     &                (idnext,id,dlist,na_models,
     &                 nd,ntot,xcur,nodex,dminx)

                 if(timing)then
                    t1 = cputime(t2,t3)
                    tup = tup + t2
                    tna = tna + t2
                 end if
                 nupd = nupd + 1
              else
c                write(*,*)' resetting dlist '

                 if(timing)then
                    t1 = cputime(t2,t3)
                    tna = tna + t2
                 end if
c                                               full update
                 call NNcalc_dlist
     &                (idnext,dlist,na_models,
     &                 nd,ntot,xcur,nodex,dminx)

                 if(timing)then
                    t1 = cputime(t2,t3)
                    tcd = tcd + t2
                    tna = tna + t2
                 end if
                 ncald = ncald + 1
                 resetlist = .false.

              end if

              id = idnext

              if(timing)then
                 t1 = cputime(t2,t3)
                 tna = tna + t2
              end if
c						Calculate intersection
c						of current Voronoi cell 
c						with current 1-D axis
c
              call NNaxis_intersect
     &             (xcur,id,dlist,na_models,nd,ntot,
     &              nodex,range(1,id),range(2,id),x1,x2)

              if(timing)then
                 t1 = cputime(t2,t3)
                 tna = tna + t2
                 taxis = taxis + t2
              end if

c
c						Generate new node in 
c						Voronoi cell of input point

              kd = id + (cell-1)*nd
              call NA_deviate (x1,x2,kd,xcur(id))

              if(timing)then
                 t1 = cputime(t2,t3)
                 tdev = tdev + t2
                 tna = tna + t2
              end if


c						check Voronoi boundaries 

              if(check)then
                 do i=1,nd
                   xdum(i) = xcur(i)
                 end do
                 xdum(id) = x1
                 call findnearest(xdum,na_models,ntot,nd,nnode)
                 write(*,*)' Nearest node to x1 = ',nnode
                 xdum(id) = x2
                 call findnearest(xdum,na_models,ntot,nd,nnode)
                 write(lu_sum,*)' Nearest node to x2 = ',nnode
                 write(*,*)' Nearest node to x2 = ',nnode
              end if
c
c						increment axis 
              idnext = idnext + 1
              if(idnext.gt.nd)idnext=1
c
           end do
           end do
c						put new sample in list
           j = ntot+is
           do i=1,nd
              na_models(i,j) = xcur(i)
           end do
c						check nearest node

           if(check)then
              call findnearest(xcur,na_models,ntot,nd,nnode)

              write(lu_sum,*)' Nearest node to new model',is+ntot,
     &                       ' = ',nnode
              write(*,*)' Nearest node to new model',is+ntot,
     &                  ' = ',nnode
              if(nnode.ne.nodex)then
                 write(lu_sum,100)nodex,nnode,is+ntot,iw,id
                 write(*,100)nodex,nnode,is+ntot,iw,id
              end if
           end if

c						find distance moved 
c						from Vcell node 

           if(calcmovement.and.ind_cell.eq.mopt)then
              dist = 0.0
              do i=1,nd
                dd = (na_models(i,nodex) - xcur(i))
                dd = dd*dd
                dist = dist + dd
              end do
              dsum = dsum + sqrt(dist)
              dcount = dcount + 1
           end if

           ind_celllast = ind_cell

           if(icount.eq.nsampercell)then
              icount = 0 
              cell = cell + 1
              ind_cellnext = mfitord(cell)
              if(cell.eq.nrem+1)nsampercell = nsampercell - 1
           end if
c

        end do
c						write average distance
c						of samples from node 
c						in optimum Vcell 
        if(calcmovement)then
           write(lu_dis,*)ntot+nsample,dsum/dcount,ind_cell
        end if
c						write out average distance
c						of samples from current Vcell
c						node
        if(timing)then
           t1 = cputime(t2,t3)
           tna = tna + t2
        end if
        if(info)cells = idiff/(real(nd*nsample))


 100    format(1x,' WARNING node no longer in original Voronoi cell:'/
     &         ,' original cell =',i7/
     &         ,'      new cell =',i7/
     &         ,'            is =',i7/
     &         ,'            iw =',i7/
     &         ,'            id =',i7/
     &         ,'         nodes :')
 101   format(1x,10(1x,i6))

        return
        end


















c
c-----------------------------------------------------------------------
c
c	NNaxis_intersect - find intersections of current Voronoi cell 
c			   with current 1-D axis.
c
c       Input:
c	      x(nd)		:point on axis
c	      dim		:dimension index (defines axis)
c	      dlist		:set of distances of base points to axis 
c	      bp(nd,nb)		:set of base points
c	      nd		:number of dimensions
c	      nb		:number of base points 
c	      resetlist		:TRUE if dlist and nodex is to be calculated
c	      nodex		:index of base node closest to x
c	      dmin_in		:distance of base node closest to x
c	      xmin		:start point along axis
c	      xmax		:end point along axis
c
c       Output:
c	      x1		:intersection of first Voronoi boundary 
c	      x2		:intersection of second Voronoi boundary 
c
c       Comment:
c	        This method uses a simple formula to exactly calculate
c		the intersections of the Voronoi cells with the 1-D axis.
c		It makes use of the perpendicluar distances of all nodes
c		to the current axis contained in the array dlist. 
c
c	        The method involves a loop over ensemble nodes for 
c		each new intersection found. For an axis intersected
c		by ni Voronoi cells the run time is proportional to ni*ne.
c
c		It is assumed that the input point x(nd) lies in
c		the Vcell of nodex, i.e. nodex is the closest node to x(nd).
c
c		Note: If the intersection points are outside of either
c		      axis range then the axis range is returned, i.e.
c
c		      		x1 is set to max(x1,xmin) and  
c		      		x2 is set to min(x2,xmin) and  
c
c                                       M. Sambridge, RSES, June 1998
c
c-----------------------------------------------------------------------
c
        Subroutine NNaxis_intersect
     &             (x,dim,dlist,bp,nd,nb,
     &              nodex,xmin,xmax,x1,x2)
        real*4          x(nd)
        real*4          bp(nd,nb)
        real*4          dlist(nb)
        integer         dim
c						search through nodes
           x1 = xmin
           x2 = xmax
           dp0   = dlist(nodex)
           x0    = bp(dim,nodex)

c	   write(*,*)
c	   write(*,*)'k ',k,' xmin ',xmin,' xmax ',xmax,' x0',x0
c	   write(*,*)'node0 = ',node0
c	   write(*,*)'left = ',left
c	   write(*,*)'right = ',right
c						find intersection of current 
c						Voronoi cell with 1-D axis
           do j=1,nodex-1
              xc    = bp(dim,j)
              dpc   = dlist(j)
c						calculate intersection of
c						interface (between nodes 
c						nodex and j) and 1-D axis.
              dx = x0 - xc
              if(dx.ne.0.0)then
                 xi = 0.5*(x0+xc+(dp0-dpc)/dx)
                 if(xi.gt.xmin.and.xi.lt.xmax)then
                    if(xi.gt.x1.and.x0.gt.xc)then
                       x1 = xi
                    else if(xi.lt.x2.and.x0.lt.xc)then
                       x2 = xi
                    end if
                 end if
              end if
           end do

           do j=nodex+1,nb
              xc    = bp(dim,j)
              dpc   = dlist(j)
c						calculate intersection of
c						interface (between nodes 
c						nodex and j) and 1-D axis.
              dx = x0 - xc
              if(dx.ne.0.0)then
                 xi = 0.5*(x0+xc+(dp0-dpc)/dx)
                 if(xi.gt.xmin.and.xi.lt.xmax)then
                    if(xi.gt.x1.and.x0.gt.xc)then
                       x1 = xi
                    else if(xi.lt.x2.and.x0.lt.xc)then
                       x2 = xi
                    end if
                 end if
              end if
           end do

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_restart - resets NA walk to start from input model.
c
c       Calls no other routines.
c
c						M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_restart
     &             (na_models,nd,mreset,x,debug,restartNA)
        real            na_models(nd,*)
        real            x(*)

        logical         restartNA
        logical         debug
c
        if(debug)then
           write(*,*)' NA_restart: reset to model ',mreset
           write(*,*)' current model on entry '
           write(*,*)(x(k),k=1,nd)
        end if

        do i=1,nd
          x(i) = na_models(i,mreset)
        end do

        restartNA = .true.

        if(debug)then
           write(*,*)' current model on exit '
           write(*,*)(x(k),k=1,nd)
        end if

        return
        end
c
c-----------------------------------------------------------------------
c
c       Subroutine NNcalc_dlist - calculates square of distance from
c                                 all base points to new axis (defined
c                                 by dimension dim through point x.
c                                 It also updates the nearest node and
c                                 distance to the point x.
c
c       This is a full update of dlist, i.e. not using a previous dlist.
c
c-----------------------------------------------------------------------
c
        Subroutine NNcalc_dlist
     &             (dim,dlist,bp,nd,nb,x,nodex,dminx)
        real*4          bp(nd,*)
        real*4          x(nd)
        real*4          dlist(*)
        integer         dim

           dmin = 0.
           do j=1,dim-1
              d = (x(j)-bp(j,1))
              d = d*d
              dmin = dmin + d
           end do
           do j=dim+1,nd
              d = (x(j)-bp(j,1))
              d = d*d
              dmin = dmin + d
           end do
           dlist(1) = dmin
           d = (x(dim)-bp(dim,1))
           d = d*d
           dmin = dmin + d
           nodex = 1
c
           do i=2,nb
              dsum = 0.
              do j=1,dim-1
                 d = (x(j)-bp(j,i))
                 d = d*d
                 dsum = dsum + d
              end do
              do j=dim+1,nd
                 d = (x(j)-bp(j,i))
                 d = d*d
                 dsum = dsum + d
              end do
              dlist(i) = dsum
              d = (x(dim)-bp(dim,i))
              d = d*d
              dsum = dsum + d
              if(dmin.gt.dsum)then
                 dmin = dsum
                 nodex = i
              end if
              dnodex = dmin
           end do

c          write(*,*)' resetlist'
c          write(*,*)' dlist',(dlist(i),i=1,nb)
c          write(*,*)' input nodex',nodex

        return
        end


c
c-----------------------------------------------------------------------
c
c	Subroutine NNupdate_dlist - calculates square of distance from 
c				     all base points to new axis, assuming
c                                    dlist contains square of all distances 
c				     to previous axis dimlast. It also
c				     updates the nearest node to the
c				     point x through which the axes pass.
c				
c
c-----------------------------------------------------------------------
c
        Subroutine NNupdate_dlist
     &             (dim,dimlast,dlist,bp,nd,nb,x,node,dmin)
        real*4          bp(nd,*)
        real*4          x(nd)
        real*4          dlist(*)
        integer         dim,dimlast

        d1 = (x(dimlast)-bp(dimlast,1))
        d1 = d1*d1
        dmin = dlist(1)+d1
        node = 1
        d2 = (x(dim)-bp(dim,1))
        d2 = d2*d2
        dlist(1) = dmin-d2
        do i=2,nb
           d1 = (x(dimlast)-bp(dimlast,i))
           ds = d1
           d1 = dlist(i)+d1*d1
           if(dmin.gt.d1)then
              dmin = d1
              node = i
           end if
           d2 = (x(dim)-bp(dim,i))
           d2 = d2*d2
           dlist(i) = d1-d2
c          if(i.eq.nb)then
c             write(*,*)' NNupdate_dlist: node 20'
c             write(*,*)' dlist ',dlist(i)
c             write(*,*)' dim ',dim
c             write(*,*)' dimlast ',dimlast
c             write(*,*)' x ',x(1),x(2)
c             write(*,*)' bp ',bp(1,20),bp(2,20)
c             write(*,*)' d1 ',ds
c             write(*,*)' d2 ',d2
c          end if

        end do

        return
        end
c-----------------------------------------------------------------------
c
c	Numerical recipes routine
c
c-----------------------------------------------------------------------
c
      SUBROUTINE indexx(n,arr,indx)
      INTEGER n,indx(n),M,NSTACK
      REAL arr(n)
      PARAMETER (M=7,NSTACK=50)
      INTEGER i,indxt,ir,itemp,j,jstack,k,l,istack(NSTACK)
      REAL a
      do 11 j=1,n
        indx(j)=j
11    continue
      jstack=0
      l=1
      ir=n
1     if(ir-l.lt.M)then
        do 13 j=l+1,ir
          indxt=indx(j)
          a=arr(indxt)
          do 12 i=j-1,1,-1
            if(arr(indx(i)).le.a)goto 2
            indx(i+1)=indx(i)
12        continue
          i=0
2         indx(i+1)=indxt
13      continue
        if(jstack.eq.0)return
        ir=istack(jstack)
        l=istack(jstack-1)
        jstack=jstack-2
      else
        k=(l+ir)/2
        itemp=indx(k)
        indx(k)=indx(l+1)
        indx(l+1)=itemp
        if(arr(indx(l+1)).gt.arr(indx(ir)))then
          itemp=indx(l+1)
          indx(l+1)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l)).gt.arr(indx(ir)))then
          itemp=indx(l)
          indx(l)=indx(ir)
          indx(ir)=itemp
        endif
        if(arr(indx(l+1)).gt.arr(indx(l)))then
          itemp=indx(l+1)
          indx(l+1)=indx(l)
          indx(l)=itemp
        endif
        i=l+1
        j=ir
        indxt=indx(l)
        a=arr(indxt)
3       continue
          i=i+1
        if(arr(indx(i)).lt.a)goto 3
4       continue
          j=j-1
        if(arr(indx(j)).gt.a)goto 4
        if(j.lt.i)goto 5
        itemp=indx(i)
        indx(i)=indx(j)
        indx(j)=itemp
        goto 3
5       indx(l)=indx(j)
        indx(j)=indxt
        jstack=jstack+2
        if(jstack.gt.NSTACK)pause 'NSTACK too small in indexx'
        if(ir-i+1.ge.j-l)then
          istack(jstack)=ir
          istack(jstack-1)=i
          ir=j-1
        else
          istack(jstack)=j-1
          istack(jstack-1)=l
          l=i
        endif
      endif
      goto 1
      END
c
c ----------------------------------------------------------------------------
c						
c	Numerical Recipes random number generator (used by NA_random)
c
c ----------------------------------------------------------------------------
      FUNCTION ran3(idum)
      INTEGER idum
      INTEGER MBIG,MSEED,MZ
C     REAL MBIG,MSEED,MZ
      REAL ran3,FAC
      PARAMETER (MBIG=1000000000,MSEED=161803398,MZ=0,FAC=1./MBIG)
C     PARAMETER (MBIG=4000000.,MSEED=1618033.,MZ=0.,FAC=1./MBIG)
      INTEGER i,iff,ii,inext,inextp,k
      INTEGER mj,mk,ma(55)
C     REAL mj,mk,ma(55)
      SAVE iff,inext,inextp,ma
      DATA iff /0/
c MOD Jean 31/10/08

c Jean's mod commented out by dwhipp (05/12)
c We had issues with multiple NA models selecting the same parameters
c      call random_number (ran3)
c      return
c END dwhipp mod

c end MOD Jean
c      write(*,*)' idum ',idum
      if(idum.lt.0.or.iff.eq.0)then
        iff=1
        mj=MSEED-iabs(idum)
        mj=mod(mj,MBIG)
        ma(55)=mj
        mk=1
        do 11 i=1,54
          ii=mod(21*i,55)
          ma(ii)=mk
          mk=mj-mk
          if(mk.lt.MZ)mk=mk+MBIG
          mj=ma(ii)
11      continue
        do 13 k=1,4
          do 12 i=1,55
            ma(i)=ma(i)-ma(1+mod(i+30,55))
            if(ma(i).lt.MZ)ma(i)=ma(i)+MBIG
12        continue
13      continue
        inext=0
        inextp=31
        idum=1
      endif
      inext=inext+1
      if(inext.eq.56)inext=1
      inextp=inextp+1
      if(inextp.eq.56)inextp=1
      mj=ma(inext)-ma(inextp)
      if(mj.lt.MZ)mj=mj+MBIG
      ma(inext)=mj
      ran3=mj*FAC
      return
      END
c
c-----------------------------------------------------------------------
c
c	Numerical recipes routine
c
c-----------------------------------------------------------------------
c
      SUBROUTINE sobseq(n,x)
      INTEGER n,MAXBIT,MAXDIM
      REAL x(*)
      PARAMETER (MAXBIT=30,MAXDIM=6)
      INTEGER i,im,in,ipp,j,k,l,ip(MAXDIM),iu(MAXDIM,MAXBIT),iv(MAXBIT*
     *MAXDIM),ix(MAXDIM),mdeg(MAXDIM)
      REAL fac
      SAVE ip,mdeg,ix,iv,in,fac
      EQUIVALENCE (iv,iu)
      DATA ip /0,1,1,2,1,4/, mdeg /1,2,3,3,4,4/, ix /6*0/
      DATA iv /6*1,3,1,3,3,1,1,5,7,7,3,3,5,15,11,5,15,13,9,156*0/
      if (n.lt.0) then
        do 14 k=1,MAXDIM
          do 11 j=1,mdeg(k)
            iu(k,j)=iu(k,j)*2**(MAXBIT-j)
11        continue
          do 13 j=mdeg(k)+1,MAXBIT
            ipp=ip(k)
            i=iu(k,j-mdeg(k))
            i=ieor(i,i/2**mdeg(k))
            do 12 l=mdeg(k)-1,1,-1
              if(iand(ipp,1).ne.0)i=ieor(i,iu(k,j-l))
              ipp=ipp/2
12          continue
            iu(k,j)=i
13        continue
14      continue
        fac=1./2.**MAXBIT
        in=0
      else
        im=in
        do 15 j=1,MAXBIT
          if(iand(im,1).eq.0)goto 1
          im=im/2
15      continue
        pause 'MAXBIT too small in sobseq'
1       im=(j-1)*MAXDIM
        do 16 k=1,min(n,MAXDIM)
          ix(k)=ieor(ix(k),iv(im+k))
          x(k)=ix(k)*fac
16      continue
        in=in+1
      endif
      return
      END
c
c-----------------------------------------------------------------------
c
c	Numerical recipes routine adapted to give ind and iselect
c
c-----------------------------------------------------------------------
c
      FUNCTION select(k,n,arr,ind,iselect)
      INTEGER k,n
      REAL select,arr(n)
      integer ind(n)
      INTEGER i,ir,j,l,mid
      REAL a,temp
      l=1
      ir=n
1     if(ir-l.le.1)then
        if(ir-l.eq.1)then
          if(arr(ir).lt.arr(l))then
            temp=arr(l)
            arr(l)=arr(ir)
            arr(ir)=temp
            itemp=ind(l)
            ind(l)=ind(ir)
            ind(ir)=itemp
          endif
        endif
        select=arr(k)
        iselect=ind(k)
        return
      else
        mid=(l+ir)/2
        temp=arr(mid)
        arr(mid)=arr(l+1)
        arr(l+1)=temp
        itemp=ind(mid)
        ind(mid)=ind(l+1)
        ind(l+1)=itemp
        if(arr(l+1).gt.arr(ir))then
          temp=arr(l+1)
          arr(l+1)=arr(ir)
          arr(ir)=temp
          itemp=ind(l+1)
          ind(l+1)=ind(ir)
          ind(ir)=itemp
        endif
        if(arr(l).gt.arr(ir))then
          temp=arr(l)
          arr(l)=arr(ir)
          arr(ir)=temp
          itemp=ind(l)
          ind(l)=ind(ir)
          ind(ir)=itemp
        endif
        if(arr(l+1).gt.arr(l))then
          temp=arr(l+1)
          arr(l+1)=arr(l)
          arr(l)=temp
          itemp=ind(l+1)
          ind(l+1)=ind(l)
          ind(l)=itemp
        endif
        i=l+1
        j=ir
        a=arr(l)
        ia=ind(l)
3       continue
          i=i+1
        if(arr(i).lt.a)goto 3
4       continue
          j=j-1
        if(arr(j).gt.a)goto 4
        if(j.lt.i)goto 5
        temp=arr(i)
        arr(i)=arr(j)
        arr(j)=temp
        itemp=ind(i)
        ind(i)=ind(j)
        ind(j)=itemp
        goto 3
5       arr(l)=arr(j)
        arr(j)=a
        ind(l)=ind(j)
        ind(j)=ia
        if(j.ge.k)ir=j-1
        if(j.le.k)l=i
      endif
      goto 1
      END
c
c ----------------------------------------------------------------------------
c
c       findnearest - finds nearest model to input point
c
c       Calls no other routines.
c
c                                               M. Sambridge, Oct. 1996
c
c ----------------------------------------------------------------------------
c
        Subroutine findnearest(smodelt,na_models,ntot,moddim,mopts)
        real            na_models(moddim,*)
        real            smodelt(*)

        common          /findnearestcom/dmin

        dmin = 0
        do i=1,moddim
          b = na_models(i,1)-smodelt(i)
          dmin = dmin + b*b
        end do
        mopts = 1
        do j=2,ntot
           d = 0
           do i=1,moddim
             b = na_models(i,j)-smodelt(i)
             d = d + b*b
           end do
           if(d.lt.dmin)then
             dmin = d
             mopts = j
           end if
        end do

        return
        end
c
c ----------------------------------------------------------------------------
c
c       irandomvalue - generates a random integer between i1 and i2.
c
c       Comments:
c                Uses either Sobol-Antonov_Saleev quasi-sequence
c                or pseudo-random number generator, depending on the 
c                logical variable sobol.
c
c                Assumes either random sequence has been initialized.
c
c                                               M. Sambridge, Aug. 1997
c
c ----------------------------------------------------------------------------
c
        Subroutine irandomvalue (i1,i2,iran)
c
        logical         sobol
        real*4          rval(2)

        common/randomtype/sobol,iseed
c
c                                               Use SAS sequence
        if(sobol)then
           call sobseq(1,rval)
           iran = i1 + int(rval(1)*(i2-i1+1))
        else
           rran = ran3(iseed)
           iran = i1 + int(rran*(i2-i1+1))
        end if

        return
        end
c ----------------------------------------------------------------------------
c
c       transform2sca - transforms model from raw to scaled units.
c
c	Input:
c	      nd		: dimension of parameter space
c	      model_raw(nd)	: model in raw co-ordinates
c	      range(2,nd)	: min and max of parameter space 
c				  in raw co-ordinates.
c	      scales(nd+1)	: range scale factors
c
c	Output:
c	      model_sca(nd)	: model in scaled co-ordinates
c
c	Comments:
c	         This routine transforms a model in raw co-ordinates 
c		 to dimensionless units determined by parameter scale factors.
c
c       Calls no other routines.
c
c                                               M. Sambridge, March 1998
c
c ----------------------------------------------------------------------------
c
        Subroutine transform2sca
     &             (model_raw,nd,range,scales,model_sca)
c
        real*4          model_sca(nd)
        real*4          model_raw(nd)
        real*4          scales(nd+1)
        real*4          range(2,nd)
c
        if(scales(1).eq.0.0)then

           do i=1,nd
              model_sca(i) = model_raw(i)
           end do

        else if(scales(1).eq.-1.0)then

           do i=1,nd
              model_sca(i) =
     &        (model_raw(i)-range(1,i))/(range(2,i)-range(1,i))
           end do

        else

           do i=1,nd
              model_sca(i) = (model_raw(i)-range(1,i))/scales(i+1)
           end do

        end if
c
        return
        end

c
c ----------------------------------------------------------------------------
c
c       transform2raw - transforms model from scaled to raw units.
c
c	Input:
c	      nd		: dimension of parameter space
c	      model_sca(nd)	: model in scaled co-ordinates
c	      range(2,nd)	: min and max of parameter space 
c				  in raw co-ordinates.
c	      scales(nd+1)	: range scale factors
c
c	Output:
c	      model_raw(nd)	: model in scaled co-ordinates
c
c	Comments:
c	         This routine transforms a model in dimensionless scaled 
c		 co-ordinates to input (raw) units.
c
c       Calls no other routines.
c
c                                               M. Sambridge, March 1998
c
c ----------------------------------------------------------------------------
c
        Subroutine transform2raw
     &             (model_sca,nd,range,scales,model_raw)
c
        real*4          model_raw(nd)
        real*4          model_sca(nd)
        real*4          scales(nd+1)
        real*4          range(2,nd)
c
        if(scales(1).eq.0.0)then

           do i=1,nd
              model_raw(i) = model_sca(i)
           end do

        else if(scales(1).eq.-1.0)then

           do i=1,nd
              b = model_sca(i)
              a = 1-b
              model_raw(i) = a*range(1,i) + b*range(2,i)
           end do

        else

           do i=1,nd
              model_raw(i) = range(1,i) + scales(i+1)*model_sca(i)
           end do

        end if
c
        return
        end
c
c ---------------------------------------------------------------------
c
c       write_nad - write a direct access file in
c                   multi-record NAD format
c
c       Input:
c             lu                : logical unit of file
c             fnme              : filename
c             nhmax             : maximum size of array header
c             ndmax             : maximum size of array data
c             nemax             : maximum size of array models
c             iform             : =0 then single record format
c                                 =1 then multi-record format (for large nd)
c
c       Output:
c             nh                : length in bytes of file header
c             nhu               : length in bytes of user portion of header
c             nd                : dimension of parameter space
c             ne                : number of models in ensemble
c             header            : header character string of length nh (char)
c             data(nd)          : array of data values for each model (real*4)
c             models(nd,ne)     : array of model values  (real*4)
c
c       Comments:
c                The direct access NAD file format:
c
c                VARIABLE       TYPE            SIZE IN BYTES
c                nd             int             4
c                ne             int             4
c                nh             int             4
c                nhu            int             4
c                header         character       nh
c                models         real*4          4*nd*ne
c                data           real*4          4*nd
c                tail           real*4          4
c
c                In single record mode a direct access file of length
c                [4x(4+nd*ne+ne+1) + nh] bytes is produced.
c
c                In multi record mode a direct access file of length
c                [(ne+1)*(max(20+nh,4(nd+1))] bytes is produced.
c
c               Calls are made to subroutine read_da.
c
c                This routine assumes that direct access
c                files are opened with the record length specified
c                in bytes. This is the default for most machines
c                but not Dec machines. (Often a compiler option is
c                available on the DEC/compaq to use bytes rather than
c                4-byte words.
c
c                                       M. Sambridge, RSES, November 2001
c
c ---------------------------------------------------------------------
c
      Subroutine write_nad
     &           (lu,fnme,nd,ne,nh,nhu,header,iform,models,data)
c
      real*4            models(nd,ne)
      real*4            data(ne)
      character         header(nh)
      real*4            tail
c     character(256)    fnme
      character*256     fnme
      logical           warn

      warn = .true.
      warn = .false.

c                                               write new
c                                               multi-record format
      if(iform.eq.1)then

c                                               calculate length of header
         len1 = 4*5+nh
         len2 = 4*(nd+1)
         mul  = 1 + (len1-1)/len2
c        write(*,*)mul
         lenh = mul*len2
         num = ne + mul
         is1 = num*len2
         is2 = 4*(5+nd*ne+ne)+nh

c        write(*,*)' Number of models                         :',ne
c        write(*,*)' Number of dimensions                     :',nd
c        write(*,*)' Original header length in bytes          :',len1
c        write(*,*)' Final header length in bytes             :',lenh
c        write(*,*)' Direct access file record length         :',len2
c        write(*,*)' Number of records                        :',num
c        write(*,*)' Size of nad file in multi-record format  :',is1
c        write(*,*)' Size of nad file in single record format :',is2

c                                                       write header
         open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=lenh)

c                                               write out header
c                                               for multi-record format

         write(lu,rec=1)-mul,nd,ne,nh,nhu,header

         close(lu)
c                                                       write models
         open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len2)

         do i=1,ne
            call wnad(lu,mul+i,nd,models(1,i),data(i))
         end do
         close(lu)


      else
c                                               write original
c                                               single record format
c
c                                               set total length of nad file
         len = 4+nd*ne+ne+1
         len = 4*len+nh

         write(*,*)' size of nad file = ',len
c                                               open direct access nad file

         open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len)

         tail = -999.0
         write(lu,rec=1)nd,ne,nh,nhu,header,models,data,tail

         close(lu)

      end if

      return
      end

      Subroutine wnad(lu,i,nd,models,data)

      real*4            models(nd)
      real*4            data

      write(lu,rec=i)models,data

      return
      end
c
c ---------------------------------------------------------------------
c
c       read_nad - read a direct access file in NAD format. 
c
c	Input:
c	      lu	      : logical unit of file
c	      fnme	      : filename 
c	      iform	      : If iform=-1 on input then just read header and return 
c	      nhmax	      : maximum size of array header
c	      ndmax	      : maximum size of array data
c	      nemax	      : maximum size of array models
c
c	Output:
c	      nh	      : total length in bytes of file header 
c	      nhu	      : length in bytes of user written part of header 
c	      iform	      : format for nad file (1=multi-record,0=single)
c	      mul	      : number of records in the header (with padding)
c	      nd	      : dimension of parameter space
c	      ne	      : number of models in ensemble
c	      header          : header character string of length nh (char)
c	      data(nd)	      : array of data values for each model (real*4)
c	      models(nd,ne)   : array of model values  (real*4)
c
c	Comments:
c                The direct access NAD file format:
c
c                VARIABLE       TYPE            SIZE IN BYTES
c                nd             int             4
c                ne             int             4
c                nh             int             4
c                nhu            int             4
c                header         character       nh
c                models         real*4          4*nd*ne
c                data           real*4          4*nd
c                tail           real*4          4
c
c                File must contain a single record of length
c                [4x(4+nd*ne+ne+1) + nh] bytes
c
c		Calls are made to subroutine read_da. 
c
c                This routine assumes that direct access
c                files are opened with the record length specified
c                in bytes. This is the default for most machines
c                but not Dec machines. (A compiler option is
c                available on the Compaq Alpha to use bytes rather than 
c                4-byte words.)
c
c					M. Sambridge, RSES, Nov. 2001
c
c ---------------------------------------------------------------------
c
      	Subroutine read_nad
     &                     (lu,fnme,nh,nhu,iform,nd,ne,
     &                      nhmax,ndmax,nemax,
     &                      header,data,models)
c
      	real*4            models(*)
      	real*4            data(*)
      	character*(*)     header
        logical           headeronly

      	character*256 	  fnme

	mul = 0
        headeronly = .false.
        if(iform.eq.-1)then
          headeronly = .true.
          iform = 0
        end if
	iform = 0
c						read in size of header
        len = 4
        open(lu,file=fnme,status='unknown',
     &       form='unformatted',access='direct',recl=len,err=100)
        read(lu,rec=1)mul
        close(lu)
c						read in number of models,
c						number of dimensions and 
c						size of header
	if(mul.gt.0)then
c						we are in single record format
          len = 16
          open(lu,file=fnme,status='unknown',
     &         form='unformatted',access='direct',recl=len)
          read(lu,rec=1)nd,ne,nh,nhu
          mul = 0
          close(lu)
	else
c						we are in multi record format
          len = 20
          open(lu,file=fnme,status='unknown',
     &         form='unformatted',access='direct',recl=len)
          read(lu,rec=1)mul,nd,ne,nh,nhu
          mul = -mul
          close(lu)
	  iform = 1
	end if
        if(headeronly)return
c						check array sizes
	if(nd.gt.ndmax)then
          write(*,*)
          write(*,*)
     &    'Error - maxmimum number of dimensions is too small'
          write(*,*)
     &    '        current maximum number of dimensions =',ndmax
          write(*,*)
     &    '        number of dimensions in input file   =',nd
          write(*,*)'        '
          write(*,*)'Remedy - increase size of parameter ndmax'
          write(*,*)'         to at least this value and recompile'
          write(*,*)'        '
          stop
        end if

	if(ne.gt.nemax)then
          write(*,*)
          write(*,*)
     &    'Error - maxmimum number of models is too small'
          write(*,*)
     &    '        current maximum number of models =',nemax
          write(*,*)
     &    '        number of models in input file   =',ne
          write(*,*)'        '
          write(*,*)'Remedy - increase size of parameter nemax'
          write(*,*)'         to at least this value and recompile'
          write(*,*)'        '
          stop
        end if

	if(nh.gt.nhmax)then
          write(*,*)
          write(*,*)
     &    'Error - maxmimum size of header is too small'
          write(*,*)
     &    '        current maximum size of header =',nhmax
          write(*,*)
     &    '        size of header in input file   =',nh
          write(*,*)'        '
          write(*,*)'Remedy - increase size of parameter nhmax'
          write(*,*)'         to at least this value and recompile'
          write(*,*)'        '
          stop
        end if

 	call read_da(lu,fnme,nd,ne,nh,mul,header,models,data)

      	return
 100    write(*,*)
        write(*,*)' Error reading file : ',fnme
        write(*,*)' Does it exist ? '
        write(*,*)
	stop

      	end
c
c ---------------------------------------------------------------------
c
c       read_da - read a direct access file containing
c                 ne models with dimension nd, ne data
c                 values and a header of size nh.
c
c       Input:
c             lu                : logical unit of file
c             fnme              : filename
c             nh                : length in bytes of file header (minus padding)
c             mul               : number of records in the header (with padding)
c             nd                : dimension of parameter space
c             ne                : number of models in ensemble
c
c       Output:
c             header            : header character string of length nh (char)
c             data(nd)          : array of data values for each model (real*4)
c             models(nd,ne)     : array of model values  (real*4)
c
c       Comments:
c                The direct access NAD file format:
c
c                VARIABLE       TYPE            SIZE IN BYTES
c                nd             int             4
c                ne             int             4
c                nh             int             4
c                header         character       nh
c                models         real*4          4*nd*ne
c                data           real*4          4*nd
c                tail           real*4          4
c
c                File must contain a single record of length
c                [4x(3+nd*ne+ne+1) + nh] bytes
c
c
c                                       M. Sambridge, RSES, Nov. 2001
c
c ---------------------------------------------------------------------
c
        Subroutine read_da(lu,fnme,nd,ne,nh,mul,header,models,data)
c
        real*4            models(nd,ne)
        real*4            data(ne)
        character         header(nh)
c       real*4            tail

c       character(256)    fnme
        character*256     fnme
c
c                                              calculate length of header
        iform = 0
        if(mul.ne.0)iform = 1

        lenh  = 4*5+nh
        len   = 4*(nd+1)

        if(iform.eq.1)then

           open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=lenh)

           read(lu,rec=1)idum1,idum2,idum3,idum4,idum5,header

           close(lu)

c          write(*,*)' record length               ',len
c          write(*,*)' header length               ',lenh
c          write(*,*)' Number of records in header ',mul
c
           open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len)

           do i=1,ne
              call rnad(lu,i+mul,nd,models(1,i),data(i))
           end do

           close(lu)

        else
c                                              read in file as
c                                              a single record
           len = 4+nd*ne+ne
           len = 4*len+nh

           open(lu,file=fnme,status='unknown',
     &          form='unformatted',access='direct',recl=len)

           read(lu,rec=1)i,j,k,kk,header,models,data

           close(lu)

        end if
c
        return
        end

        Subroutine rnad(lu,i,nd,models,data)

        real*4            models(nd)
        real*4            data

        read(lu,rec=i)models,data

        return
        end
c
c ----------------------------------------------------------------------------
c
c       cputime - calls system dependent routine to calculate cputime
c		  since last call.
c
c       Calls dtime.
c						M. Sambridge, June 2001
c
c ----------------------------------------------------------------------------
c
        Function cputime(t1,t2)
        real*4 t1,t2
        real*4 tarray(2)
        
        cputime = dtime(tarray)
        t1 = tarray(1)
        t2 = tarray(2)

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_header - writes NA-specific information to NAD header.
c
c		    This routine adds various NA-header info to
c		    the header written by the user.
c
c       Calls no other routines.
c
c						M. Sambridge, June 1999
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_header
     &             (lu,fnme,header,nh_max,nh,nd,
     &              range,scales,n1,n2,n3,nhu)
        real*4            range(2,nd)
        real*4            scales(nd+1)
        character         header(*)
c       character(256)    fnme
        character*256     fnme

c                                               calculate total header length
        rlen = 3*nd + 4
        len = 4*rlen+nh
        nhu = nh
        nh_na   = 4*rlen
        nh_tot  = len
c	write(*,*)' nh_user = ',nhu
c	write(*,*)' nh_na   = ',nh_na  
c	write(*,*)' nh_tot  = ',nh_tot 

        if(nh_tot.gt.nh_max)then
           write(*,*)
           write(*,*)' Error - header array too small'
           write(*,*)
           write(*,*)'         current size = ',nh_max
           write(*,*)'        required size = ',nh_tot
           write(*,*)
           write(*,*)' Remedy - adjust nh_max in parameter',
     &                        ' file and recompile'
           write(*,*)
           call abort
        end if

c						write out header information
        call write_header
     &       (lu,fnme,len,nd,nh,range,scales,n1,n2,n3,header)

        nh = nh_tot
c						read header information
c						into character string
        call read_header
     &       (lu,fnme,nh,len,header)


c	write(50,*)header(nh_na+1:nh_tot)

        return
        end
c
c ----------------------------------------------------------------------------
c
c       read_header - converts header information into a character
c		      string by writing it to a direct access file
c		      and then reading it back as a character string
c
c       Calls no other routines.
c
c						M. Sambridge, June 1999
c
c ----------------------------------------------------------------------------
c
c                                               open direct access 
c						temporary file
        Subroutine read_header
     &             (lu,fnme,nh,len,header)

        character         header(nh)
c       character(256)    fnme
        character*256     fnme

        open(lu,file=fnme,status='unknown',
     &       form='unformatted',access='direct',recl=len)

        read(lu,rec=1)header

        close(lu)

        return
        end
c
c ----------------------------------------------------------------------------
c
c       write_header - converts header information into a character
c		       string by writing it to a direct access file
c		       and then reading it back as a character string
c
c       Calls no other routines.
c
c						M. Sambridge, June 1999
c
c ----------------------------------------------------------------------------
c
c                                               open direct access 
c						temporary file
        Subroutine write_header
     &             (lu,fnme,len,nd,nh,
     &              range,scales,n1,n2,n3,header)
        real*4            range(2,nd)
        real*4            scales(nd+1)
        character         header(nh)
c       character(256)    fnme
        character*256     fnme

        open(lu,file=fnme,status='unknown',
     &       form='unformatted',access='direct',recl=len)

        write(lu,rec=1)n1,n2,n3,range,scales,header

        close(lu)

        return
        end
c
c ----------------------------------------------------------------------------
c
c       NA_display - writes out current best fit model 
c		     to LU lu_det with misfit information
c
c       Calls no other routines.
c
c						M. Sambridge, Sept. 1999
c
c ----------------------------------------------------------------------------
c
        Subroutine NA_display
     &             (lu_det,model_opt,it,nd,ntot,
     &              mfitmin,mfitminc,mfitmean,mopt)
        real*4          model_opt(*)
        real*4          mfitmin,mfitmean,mfitminc

        write(lu_det,*)' Iteration              ',
     &                 '           : ',it
        write(lu_det,*)' Total number of samples ',
     &                 '          : ',ntot
        write(lu_det,*)
     &  ' Minimum misfit                    : ',mfitmin
        write(lu_det,*)
     &  ' Minimum misfit for this iteration : ',mfitminc
        write(lu_det,*)
     &  ' Mean misfit in this iteration     : ',mfitmean
        write(lu_det,*)
     &  ' Index of best fitting model       : ',mopt
        write(lu_det,*)

c						write out optimum model

        write(lu_det,*)' Parameter   best fitting model'
        do i=1,nd
           write(lu_det,*)' ',i,' : ',model_opt(i)
        end do
        write(lu_det,100)
        
 100    format(/,72("-")/)
        

        return
        end
c
c ----------------------------------------------------------------------------
c
c       jumble - randomly re-arranges input array  
c
c       Calls ran3 and assumes that it has been initialized.
c
c                                               M. Sambridge, Oct. 1999.
c
c ----------------------------------------------------------------------------
c
        Subroutine jumble(iarr,arr,n)
        implicit none 
        integer         n
        integer         iarr(n)
        real*4          arr(n)
        integer         iseed
        real*4          sobol 
        common/randomtype/sobol,iseed

        real*4 rn,val,ran3
        integer j,k,ival

        rn = n
        do j=1,n
           val = ran3(iseed)
           k = 1 + int(val*rn)
           if(k.eq.n+1)then
              k = n
           else if(k.gt.n)then
              write(*,*)' error in jumble k'
     &        ,k,' val',val,' rn',rn
              call abort
           end if
           ival = iarr(j)
           iarr(j) = iarr(k)
           iarr(k) = ival
           val = arr(j)
           arr(j) = arr(k)
           arr(k) = val
        end do


        return
        end
c
c ----------------------------------------------------------------------------
c
c       abort - randomly re-arranges input array  
c						Used in place of a stop
c						to ensure that all 
c						processes are stopped
c						in MPI mode
c
c ----------------------------------------------------------------------------
c
        Subroutine abort
        implicit none
#if NA_MPI
        include "mpif.h"
        integer ierr
        call mpi_abort(MPI_COMM_WORLD, ierr)
#endif
        stop
        end

